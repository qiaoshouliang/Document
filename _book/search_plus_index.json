{"./":{"url":"./","title":"Introduction","keywords":"","body":"Document 突然发现有这么一个工具gitbook，不仅简洁美观，而且可以用git进行版本管理，于是萌生了一些想法： 用它来记录一些技术难点问题。 对自己以前比较模糊的知识点进行深度总结。 激励自己学习一些新的技术。 既然萌生了这个想法，那就开始干吧。写一本只属于我自己的书～ 加油！！！！ Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:41:54 var className='atoc';"},"Android/Index.html":{"url":"Android/Index.html","title":"Android","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/第三方库/":{"url":"Android/第三方库/","title":"第三方库","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/第三方库/EventBus的使用方式.html":{"url":"Android/第三方库/EventBus的使用方式.html","title":"EventBus的使用方式","keywords":"","body":"添加EventBus 在app/build.gradle下添加 defaultConfig { ... javaCompileOptions { annotationProcessorOptions { arguments = [eventBusIndex : 'org.greenrobot.eventbus.perf.EventBusIndex'] } } } dependencies { /* EventBus */ compile 'org.greenrobot:eventbus:3.0.0' annotationProcessor 'org.greenrobot:eventbus-annotation-processor:3.0.1' } 随意创建一个subscribe的event @Subscribe(threadMode = ThreadMode.POSTING) public void message (MessageA event){ } 注：为什么要创建这个subscribe的event，主要是由于注解预编译首先要在项目中有一个注解@Subscribe，否则无法预编译 重新Rebuild Project Rebuild Project 之后就会在build目录下生产EventBusIndex这个类 在Application类下加入EventBus.builder().addIndex(new EventBusIndex()).installDefaultEventBus(); Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/第三方库/RxJava操作符的使用.html":{"url":"Android/第三方库/RxJava操作符的使用.html","title":"RxJava操作符的使用","keywords":"","body":"创建操作 以下操作符用于创建Observable create： 使用OnSubscribe从头创建一个Observable，这种方法比较简单。 需要注意的是，使用该方法创建时，建议在OnSubscribe#call方法中检查订阅状态，以便及时停止发射数据或者运算。 Observable.create(new Observable.OnSubscribe() { @Override public void call(Subscriber subscriber) { subscriber.onNext(\"item1\"); subscriber.onNext(\"item2\"); subscriber.onCompleted(); } }); from： 将一个Iterable, 一个Future, 或者一个数组，内部通过代理的方式转换成一个Observable。Future转换为OnSubscribe是通过OnSubscribeToObservableFuture进行的，Iterable转换通过OnSubscribeFromIterable进行。数组通过OnSubscribeFromArray转换。 //Iterable List list=new ArrayList<>(); ... Observable.from(list) .subscribe(new Action1() { @Override public void call(String s) { } }); //Future Future futrue= Executors.newSingleThreadExecutor().submit(new Callable() { @Override public String call() throws Exception { Thread.sleep(1000); return \"maplejaw\"; } }); Observable.from(futrue) .subscribe(new Action1() { @Override public void call(String s) { } }); ; just： 将一个或多个对象转换成发射这个或这些对象的一个Observable。如果是单个对象，内部创建的是ScalarSynchronousObservable对象。如果是多个对象，则是调用了from方法创建。 empty： 创建一个什么都不做直接通知完成的Observable error： 创建一个什么都不做直接通知错误的Observable never： 创建一个什么都不做的Observable Observable observable1=Observable.empty();//直接调用onCompleted。 Observable observable2=Observable.error(new RuntimeException());//直接调用onError。这里可以自定义异常 Observable observable3=Observable.never();//啥都不做 timer： 创建一个在给定的延时之后发射数据项为0的Observable,内部通过OnSubscribeTimerOnce工作 Observable.timer(1000,TimeUnit.MILLISECONDS) .subscribe(new Action1() { @Override public void call(Long aLong) { Log.d(\"JG\",aLong.toString()); // 0 } }); interval： 创建一个按照给定的时间间隔发射从0开始的整数序列的Observable，内部通过OnSubscribeTimerPeriodically工作。 Observable.interval(1, TimeUnit.SECONDS) .subscribe(new Action1() { @Override public void call(Long aLong) { //每隔1秒发送数据项，从0开始计数 //0,1,2,3.... } }); range： 创建一个发射指定范围的整数序列的Observable Observable.range(2,5).subscribe(new Action1() { @Override public void call(Integer integer) { Log.d(\"JG\",integer.toString());// 2,3,4,5,6 从2开始发射5个数据 } }); defer： 只有当订阅者订阅才创建Observable，为每个订阅创建一个新的Observable。内部通过OnSubscribeDefer在订阅时调用Func0创建Observable。 Observable.defer(new Func0>() { @Override public Observable call() { return Observable.just(\"hello\"); } }).subscribe(new Action1() { @Override public void call(String s) { Log.d(\"JG\",s); } }); 合并操作 以下操作符用于组合多个Observable。 concat： 按顺序连接多个Observables。需要注意的是Observable.concat(a,b)等价于a.concatWith(b)。 Observable observable1=Observable.just(1,2,3,4); Observable observable2=Observable.just(4,5,6); Observable.concat(observable1,observable2) .subscribe(item->Log.d(\"JG\",item.toString()));//1,2,3,4,4,5,6 startWith： 在数据序列的开头增加一项数据。startWith的内部也是调用了concat Observable.just(1,2,3,4,5) .startWith(6,7,8) .subscribe(item->Log.d(\"JG\",item.toString()));//6,7,8,1,2,3,4,5 merge： 将多个Observable合并为一个。不同于concat，merge不是按照添加顺序连接，而是按照时间线来连接。其中mergeDelayError将异常延迟到其它没有错误的Observable发送完毕后才发射。而merge则是一遇到异常将停止发射数据，发送onError通知。 zip： 使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。如果多个Observable发射的数据量不一样，则以最少的Observable为标准进行压合。内部通过OperatorZip进行压合。 Observable observable1=Observable.just(1,2,3,4); Observable observable2=Observable.just(4,5,6); Observable.zip(observable1, observable2, new Func2() { @Override public String call(Integer item1, Integer item2) { return item1+\"and\"+item2; } }) .subscribe(item->Log.d(\"JG\",item)); //1and4,2and5,3and6 combineLatest： 当两个Observables中的任何一个发射了一个数据时，通过一个指定的函数组合每个Observable发射的最新数据（一共两个数据），然后发射这个函数的结果。 如下图所示： Observable1发射完1之后，1是这个Observable1的最新数据，Observable2发射完A之后，A是这个Observable2的最新数据，结果就返回1A。 当Observable1发射完2之后，2是这个Observable1的最新数据，Observable2的最新数据还是A，结果就是2A。 当Observable2发射完B之后，B是这个Observable2的最新数据, Observable1的最新数据还是2，结果就是2B。 .... 类似于zip，但是，不同的是zip只有在每个Observable都发射了数据才工作，而combineLatest任何一个发射了数据都可以工作，每次与另一个Observable最近的数据压合。具体请看下面流程图。 过滤操作 filter： 过滤数据。内部通过OnSubscribeFilter过滤数据。 Observable.just(3,4,5,6) .filter(new Func1() { @Override public Boolean call(Integer integer) { return integer>4; } }) .subscribe(item->Log.d(\"JG\",item.toString())); //5,6 ofType： 过滤指定类型的数据，与filter类似 Observable.just(1,2,\"3\") .ofType(Integer.class) .subscribe(item -> Log.d(\"JG\",item.toString()));//3 take： 只发射开始的N项数据或者一定时间内的数据。内部通过OperatorTake和OperatorTakeTimed过滤数据。 Observable.just(3,4,5,6) .take(3)//发射前三个数据项 .take(100, TimeUnit.MILLISECONDS)//发射100ms内的数据 takeLast： 只发射最后的N项数据或者一定时间内的数据。内部通过OperatorTakeLast和OperatorTakeLastTimed过滤数据。takeLastBuffer和takeLast类似，不同点在于takeLastBuffer会收集成List后发射 Observable.just(3,4,5,6) .takeLast(3) .subscribe(integer -> Log.d(\"JG\",integer.toString()));//4,5,6 takeFirst： 提取满足条件的第一项。内部实现源码如下： public final Observable takeFirst(Func1 predicate) { return filter(predicate).take(1); //先过滤，后提取 } first/firstOrDefault： 只发射第一项（或者满足某个条件的第一项）数据，可以指定默认值。 Observable.just(3,4,5,6) .first() .subscribe(integer -> Log.d(\"JG\",integer.toString()));//3 Observable.just(3,4,5,6) .first(new Func1() { @Override public Boolean call(Integer integer) { return integer>3; } }) .subscribe(integer -> Log.d(\"JG\",integer.toString()));//4 last/lastOrDefault： 只发射最后一项（或者满足某个条件的最后一项）数据，可以指定默认值。 skip： 跳过开始的N项数据或者一定时间内的数据。内部通过OperatorSkip和OperatorSkipTimed实现过滤。 Observable.just(3,4,5,6) .skip(1) .subscribe(integer -> Log.d(\"JG\",integer.toString()));//4,5,6 skipLast： 跳过最后的N项数据或者一定时间内的数据。内部通过OperatorSkipLast和OperatorSkipLastTimed实现过滤。 elementAt/elementAtOrDefault： 发射某一项数据，如果超过了范围可以的指定默认值。内部通过OperatorElementAt过滤。 Observable.just(3,4,5,6) .elementAt(2) .subscribe(item->Log.d(\"JG\",item.toString())); //5 ignoreElements： 丢弃所有数据，只发射错误或正常终止的通知。内部通过OperatorIgnoreElements实现。 distinct： 过滤重复数据，内部通过OperatorDistinct实现。 Observable.just(3,4,5,6,3,3,4,9) .distinct() .subscribe(item->Log.d(\"JG\",item.toString())); //3,4,5,6,9 distinctUntilChanged： 过滤掉连续重复的数据。内部通过OperatorDistinctUntilChanged实现 Observable.just(3,4,5,6,3,3,4,9) .distinctUntilChanged() .subscribe(item->Log.d(\"JG\",item.toString())); //3,4,5,6,3,4,9 throttleFirst： 定期发射Observable发射的第一项数据。内部通过OperatorThrottleFirst实现。 Observable.create(subscriber -> { subscriber.onNext(1); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(2); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(3); try { Thread.sleep(1000); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(4); subscriber.onNext(5); subscriber.onCompleted(); }).throttleFirst(999, TimeUnit.MILLISECONDS) .subscribe(item-> Log.d(\"JG\",item.toString())); //结果为1,3,4 throttleWithTimeout/debounce： 发射数据时，如果两次数据的发射间隔小于指定时间，就会丢弃前一次的数据,直到指定时间内都没有新数据发射时才进行发射 Observable.create(subscriber -> { subscriber.onNext(1); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(2); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(3); try { Thread.sleep(1000); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(4); subscriber.onNext(5); subscriber.onCompleted(); }).debounce(999, TimeUnit.MILLISECONDS)//或者为throttleWithTimeout(1000, TimeUnit.MILLISECONDS) .subscribe(item-> Log.d(\"JG\",item.toString())); //结果为3,5 sample/throttleLast： 定期发射的Observable离时间点最近的数据。内部通过OperatorSampleWithTime实现。 Observable.create(subscriber -> { subscriber.onNext(1); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(2); try { Thread.sleep(500); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(3); try { Thread.sleep(1000); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(4); subscriber.onNext(5); subscriber.onCompleted(); }).sample(999, TimeUnit.MILLISECONDS)//或者为throttleLast(1000, TimeUnit.MILLISECONDS) .subscribe(item-> Log.d(\"JG\",item.toString())); //结果为2,3,5 timeout： 如果原始Observable过了指定的一段时长没有发射任何数据，就发射一个异常或者使用备用的Observable。 Observable.create(( subscriber) -> { subscriber.onNext(1); try { Thread.sleep(1000); } catch (InterruptedException e) { throw Exceptions.propagate(e); } subscriber.onNext(2); subscriber.onCompleted(); }).timeout(999, TimeUnit.MILLISECONDS,Observable.just(99,100))//如果不指定备用Observable将会抛出异常 .subscribe(item-> Log.d(\"JG\",item.toString()),error->Log.d(\"JG\",\"onError\")); //结果为1,99,100 如果不指定备用Observable结果为1,onError } 条件/布尔操作 all： 判断所有的数据项是否满足某个条件，内部通过OperatorAll实现。 Observable.just(2,3,4,5) .all(new Func1() { @Override public Boolean call(Integer integer) { return integer>3; } }) .subscribe(new Action1() { @Override public void call(Boolean aBoolean) { Log.d(\"JG\",aBoolean.toString()); //false } }); exists： 判断是否存在数据项满足某个条件。内部通过OperatorAny实现。 Observable.just(2,3,4,5) .exists(integer -> integer>3) .subscribe(aBoolean -> Log.d(\"JG\",aBoolean.toString())); //true contains： 判断在发射的所有数据项中是否包含指定的数据，内部调用的其实是exists Observable.just(2,3,4,5) .contains(3) .subscribe(aBoolean -> Log.d(\"JG\",aBoolean.toString())); //true sequenceEqual： 用于判断两个Observable发射的数据是否相同（数据，发射顺序，终止状态）。 Observable.sequenceEqual(Observable.just(2,3,4,5),Observable.just(2,3,4,5)) .subscribe(aBoolean -> Log.d(\"JG\",aBoolean.toString()));//true isEmpty： 用于判断Observable发射完毕时，有没有发射数据。有数据false，如果只收到了onComplete通知则为true。 Observable.just(3,4,5,6) .isEmpty() .subscribe(item -> Log.d(\"JG\",item.toString()));//false amb： 给定多个Observable，只让第一个发射数据的Observable发射全部数据，其他Observable将会被忽略。 Observable observable1=Observable.create(new Observable.OnSubscribe() { @Override public void call(Subscriber subscriber) { try { Thread.sleep(1000); } catch (InterruptedException e) { subscriber.onError(e); } subscriber.onNext(1); subscriber.onNext(2); subscriber.onCompleted(); } }).subscribeOn(Schedulers.computation()); Observable observable2=Observable.create(subscriber -> { subscriber.onNext(3); subscriber.onNext(4); subscriber.onCompleted(); }); Observable.amb(observable1,observable2) .subscribe(integer -> Log.d(\"JG\",integer.toString())); //3,4 switchIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就使用备用的Observable。 Observable.empty() .switchIfEmpty(Observable.just(2,3,4)) .subscribe(o -> Log.d(\"JG\",o.toString())); //2,3,4 defaultIfEmpty： 如果原始Observable正常终止后仍然没有发射任何数据，就发射一个默认值,内部调用的switchIfEmpty。 takeUntil： 当发射的数据满足某个条件后（包含该数据），或者第二个Observable发送完毕，终止第一个Observable发送数据。 Observable.just(2,3,4,5) .takeUntil(new Func1() { @Override public Boolean call(Integer integer) { return integer==4; } }).subscribe(integer -> Log.d(\"JG\",integer.toString())); //2,3,4 takeWhile： 当发射的数据满足某个条件时（不包含该数据），Observable终止发送数据。 Observable.just(2,3,4,5) .takeWhile(new Func1() { @Override public Boolean call(Integer integer) { return integer==4; } }) .subscribe(integer -> Log.d(\"JG\",integer.toString())); //2,3 skipUntil： 丢弃Observable发射的数据，直到第二个Observable发送数据。（丢弃条件数据） skipWhile： 丢弃Observable发射的数据，直到一个指定的条件不成立（不丢弃条件数据） 聚合操作 reduce： 对序列使用reduce()函数并发射最终的结果,内部使用OnSubscribeReduce实现。 Observable.just(2,3,4,5) .reduce(new Func2() { @Override public Integer call(Integer sum, Integer item) { return sum+item; } }) .subscribe(integer -> Log.d(\"JG\",integer.toString()));//14 collect： 使用collect收集数据到一个可变的数据结构。 Observable.just(3,4,5,6) .collect(new Func0>() { //创建数据结构 @Override public List call() { return new ArrayList(); } }, new Action2, Integer>() { //收集器 @Override public void call(List integers, Integer integer) { integers.add(integer); } }) .subscribe(new Action1>() { @Override public void call(List integers) { } }); count/countLong： 计算发射的数量，内部调用的是reduce 转换操作 toList： 收集原始Observable发射的所有数据到一个列表，然后返回这个列表. Observable.just(2,3,4,5) .toList() .subscribe(new Action1>() { @Override public void call(List integers) { } }); toSortedList： 收集原始Observable发射的所有数据到一个有序列表，然后返回这个列表。 Observable.just(6,2,3,4,5) .toSortedList(new Func2() {//自定义排序 @Override public Integer call(Integer integer, Integer integer2) { return integer-integer2; //>0 升序 ，>() { @Override public void call(List integers) { Log.d(\"JG\",integers.toString()); // [2, 3, 4, 5, 6] } }); toMap： 将序列数据转换为一个Map。我们可以根据数据项生成key和生成value Observable.just(6,2,3,4,5) .toMap(new Func1() { @Override public String call(Integer integer) { return \"key：\" + integer; //根据数据项生成map的key } }, new Func1() { @Override public String call(Integer integer) { return \"value：\"+integer; //根据数据项生成map的kvalue } }).subscribe(new Action1>() { @Override public void call(Map stringStringMap) { Log.d(\"JG\",stringStringMap.toString()); // {key：6=value：6, key：5=value：5, key：4=value：4, key：2=value：2, key：3=value：3} } }); toMultiMap： 类似于toMap，不同的地方在于map的value是一个集合 变换操作 map： 对Observable发射的每一项数据都应用一个函数来变换。 Observable.just(6,2,3,4,5) .map(integer -> \"item:\"+integer) .subscribe(s -> Log.d(\"JG\",s));//item:6,item:2.... cast： 在发射之前强制将Observable发射的所有数据转换为指定类型 flatMap： 将Observable发射的数据变换为Observables集合，然后将这些Observable发射的数据平坦化的放进一个单独的Observable，内部采用merge合并。 Observable.just(2,3,5) .flatMap(new Func1>() { @Override public Observable call(Integer integer) { return Observable.create(subscriber -> { subscriber.onNext(integer*10+\"\"); subscriber.onNext(integer*100+\"\"); subscriber.onCompleted(); }); } }) .subscribe(o -> Log.d(\"JG\",o)) //20,200,30,300,50,500 flatMapIterable： 和flatMap的作用一样，只不过生成的是Iterable而不是Observable。 Observable.just(2,3,5) .flatMapIterable(new Func1>() { @Override public Iterable call(Integer integer) { return Arrays.asList(integer*10+\"\",integer*100+\"\"); } }).subscribe(new Action1() { @Override public void call(String s) { } }); concatMap： 类似于flatMap，由于内部使用concat合并，所以是按照顺序连接发射。 switchMap： 和flatMap很像，将Observable发射的数据变换为Observables集合，当原始Observable发射一个新的数据（Observable）时，它将取消订阅前一个Observable。 Observable.create(new Observable.OnSubscribe() { @Override public void call(Subscriber subscriber) { for(int i=1;i>() { @Override public Observable call(Integer integer) { //每当接收到新的数据，之前的Observable将会被取消订阅 return Observable.create(new Observable.OnSubscribe() { @Override public void call(Subscriber subscriber) { subscriber.onNext(integer*10); Utils.sleep(500,subscriber); subscriber.onNext(integer*100); subscriber.onCompleted(); } }).subscribeOn(Schedulers.newThread()); } }) .subscribe(s -> Log.d(\"JG\",s.toString()));//10,20,30,300 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/第三方库/SQLScout的安装方法.html":{"url":"Android/第三方库/SQLScout的安装方法.html","title":"SQLScout的安装方法","keywords":"","body":"官网：http://www.idescout.com/download/ 1. 安装SQLScout插件 打开Android Studio Settings(on Windows and Linux) or Preferences(Mac) Plugins Browse Repositories... 选择SQLScout并安装2. 激活SQLScout 在试用期过后，需要购买一个商业证书来激活SQLScout。 通过这里 [购买商业证书] (https://www.idescout.com/secure/buy)，然后点击Activate按钮。3. 破解 注意：以下破解只供学习讨论，请勿传播3.1 破解SQLScout 通过前面的方法安装SQLScout插件之后，进入Intellij IDEA插件安装目录： ~/Library/Application Support/AndroidStudiox.x/SQLScout/lib/ 反编译SQLScout.jar 进入com/idescout/sqlite/license/，使用javassist修改License.class如下： ClassPool pool = ClassPool.getDefault(); CtClass c = pool.get(\"com.idescout.sqlite.license.License\"); CtMethod m1 = c.getDeclaredMethod(\"isValidLicense\"); m1.setBody(\"{ return true; }\"); CtMethod m2 = c.getDeclaredMethod(\"isValidLicense\", new CtClass[]{pool.makeClass(\"com.intellij.openapi.project.Project\")}); m2.setBody(\"{ return true; }\"); c.writeFile(); 编译后复制License.class文件，替换原来的License.class。 然后jar cvf SQLScout.jar ./*打包jar。 最后替换~/Library/Application Support/AndroidStudio/SQLScout/lib/下的SQLScout.jar文件，重启Android Studio。 3.3 破解文件下载 使用方式，下载下面的SQLScout.jar和SQLScout_console_part.jar，替换~/Library/Application Support/AndroidStudio../SQLScout/lib/SQLScout.jar文件，重启AndroidStudio即可。 SQLScout 2.0.8: 支持Android Studio 2.3 下载： https://github.com/wangjiegulu/wangjiegulu.github.com/tree/master/file/SQLScout/2.0.8 SQLScout 2.0.7: 支持Android Studio 2.2 下载： https://github.com/wangjiegulu/wangjiegulu.github.com/tree/master/file/SQLScout/2.0.7 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/性能优化/":{"url":"Android/性能优化/","title":"性能优化","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/性能优化/问题总结.html":{"url":"Android/性能优化/问题总结.html","title":"问题总结","keywords":"","body":" synchronized 使用不当,在synchronized代码块中不要以非final变量（non final field）为锁，因为非final变量的引用常常会改变，一旦锁改变了，那synchronization就失去了意义。比如这个例子，一旦对String变量进行操作，就在内存中生成新的String对象 private String getString(String key) { synchronized (syncObject) { String value = null; if (null != EasyLink2_0_APP.getAppContext()) { SharedPreferences preferences = EasyLink2_0_APP.getAppContext() .getSharedPreferences(SH_PREFERENCE, Activity.MODE_PRIVATE); value = preferences.getString(key, \"\"); } return value; } } 没有实际意义的代码，影响性能 string.toString() initial.substring(0); String.format(\"has reached the top\") new String(wifiId); 需要频繁的拼接String的时候，使用\\'+\\'拼接会影响性能，应该用StringBuilder或者StringBuffer的append反方法来拼接，从执行速度上来讲：StringBuilder > StringBuffer > String，但StringBuilder是非线程安全的，StringBuffer是线程安全的。 sb.append((int) ((float) m.leftTopPoint.x / this.getWidth() * WIDTH) + \",\" + (int) ((float) m.leftTopPoint.y / this.getHeight() * HEIGHT) + \",\" + (int) ((float) m.rightBottomPoint.x / this.getWidth() * WIDTH) + \",\" + (int) ((float) m.rightBottomPoint.y / this.getHeight() * HEIGHT) + \";\"); sb.append((int) ((float) m.leftTopPoint.x / this.getWidth() * WIDTH)).append(\",\").append((int) ((float) m.leftTopPoint.y / this.getHeight() * HEIGHT)).append(\",\").append((int) ((float) m.rightBottomPoint.x / this.getWidth() * WIDTH)).append(\",\").append((int) ((float) m.rightBottomPoint.y / this.getHeight() * HEIGHT)).append(\";\"); 整型转字符串时影响性能 11+\"\" -> String.valueOf(a) Integer.toString(a) ==和equals使用不当 id.equals(0) device1.getDeviceId() == device.getDeviceId() mDeviceId!=\"\" Handler 内存泄漏 (99) private final Handler mHandler = new Handler() { public void handleMessage(Message msg) { switch(msg.what){ case MESSAGE_KEY_FOR_GET_HOME_DEVICE_LIST_SUCCEED: DeviceListNoRoom.clear(); Log.d(TAG, \"mHandler----mHomeDeviceData.size() = \" + mHomeDeviceData.size()); DeviceListNoRoom.addAll(getDeviceListNoRoom(mHomeDeviceData)); Log.d(TAG, \"mHandler----DeviceListNoRoom.size() = \" + DeviceListNoRoom.size()); ListForLV.clear(); ListForLV.addAll(DeviceListNoRoom); String item; for(int i = 0; i ​ HashMap 转成 SparseArray （8） private HashMap isSelected = new HashMap(); 布局中的LinerLayout 设置weight 时没有设置0dp （47） ​ 布局层级太深 'activity_home_page.xml' has more than 10 levels, bad for performance ​ 自定义view的onDraw使用new生成对象，消耗大量内存 （8） @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); canvas.setDrawFilter(new PaintFlagsDrawFilter(0, Paint.ANTI_ALIAS_FLAG|Paint.FILTER_BITMAP_FLAG)); float cx = getWidth() / 2; float cy = getHeight() / 2; Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setStrokeWidth(1); paint.setStyle(Paint.Style.FILL_AND_STROKE); paint.setAntiAlias(true); paint.setColor(NORMAL_COLOR); Paint selectPaint = new Paint(Paint.ANTI_ALIAS_FLAG); selectPaint.setStyle(Paint.Style.FILL); selectPaint.setAntiAlias(true); selectPaint.setColor(SELECT_COLOR); RectF smallRect = new RectF(cx - SMALL_RADIUS, cy - SMALL_RADIUS, cx + SMALL_RADIUS, cy + SMALL_RADIUS); Path p = new Path(); p.addArc(smallRect, 0, 360); RectF largeRect = new RectF(cx - BIG_RADIUS, cy - BIG_RADIUS, cx + BIG_RADIUS, cy + BIG_RADIUS); startAngle = 0; Paint paint1 = new Paint(Paint.ANTI_ALIAS_FLAG); ... return; } ​ TypedArray 没有回收 （1） protected void initViews(AttributeSet attrs) { TypedArray arr = getContext().obtainStyledAttributes(attrs, R.styleable.PtrClassicHeader, 0, 0); if (arr != null) { mRotateAniTime = arr.getInt(R.styleable.PtrClassicHeader_ptr_rotate_ani_time, mRotateAniTime); } buildAnimation(); View header = LayoutInflater.from(getContext()).inflate(R.layout.cube_ptr_classic_default_header, this); mRotateView = header.findViewById(R.id.ptr_classic_header_rotate_view); mTitleTextView = (TextView) header.findViewById(R.id.ptr_classic_header_rotate_view_header_title); mLastUpdateTextView = (TextView) header.findViewById(R.id.ptr_classic_header_rotate_view_header_last_update); mProgressBar = header.findViewById(R.id.ptr_classic_header_rotate_view_progressbar); resetView(); } ​ 缺少baselineAligned属性，当LinerLayout的子View都是ViewGroup（自定义控件除外）时，Lint认为它的子View已经不需要基准线对齐了，为了不让LinerLayout去做无用的计算对齐的操作，提出了如上警告，修改掉之后就可以提高性能。（13） ... ​ 静态成员变量直接引用或间接引用Context导致内存泄漏（101） public class AccountToastNotify { private final static String TAG = \"AccountToast\"; public final static int LENGTH_SHORT = 0; public final static int LENGTH_LONG = 1; private static Context mContext = EasyLink2_0_APP.getAppContext(); private static Resources mResources = EasyLink2_0_APP.getAppContext().getResources(); ...... } ​ 无用的布局嵌套（107） bitMap没有回收，导致内存泄漏 if (name.equals(getString(R.string.bedroom_zhu)) || name.equals(getString(R.string.bedroom))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_bedroom); } else if (name.equals(getString(R.string.bedroom_guest)) || name.equals(getString(R.string.bedroom_ci))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_guest_bedroom); } else if (name.equals(getString(R.string.room_balcony))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_balcony); } else if (name.equals(getString(R.string.child_room))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_child_room); } else if (name.equals(getString(R.string.washroom))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_washroom); } else if (name.equals(getString(R.string.room_kitchen))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_kitchen); } else if (name.equals(getString(R.string.room_saloon))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_saloon); } else if (name.equals(getString(R.string.room_study))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_study); } else if (name.equals(getString(R.string.dining_room))) { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bg_dining_room); } else { bitmap = BitmapFactory.decodeResource(getResources(), R.drawable.default_room); } 网络请求次数过多-刷新设备状态 首先刷新Wi-Fi状态，然后获取网关设备的状态，并且是在一个线程中循序执行，如果设备较多，那么最多可能需要顺序请求60多次Http 请求，并且需要上一个请求有返回之后才会请求下一个。严重影响用户体验。 for (String wifiId : wifiIdList) { Log.d(TAG, \"refleshOnline: \" + wifiId); int ret = HomesDataUtil.wifiStatusHttp(wifiId); if (ret != 1 && ret != 0) { Log.e(TAG, \"wifiStatusHttp err: \" + ret); } boolean local = WiFiManager.check(wifiId); devOnlineUpdate(wifiId, ret, (local ? 1 : 0)); } for (DeviceParaApi dev : list) { if (dev.getVisible() && dev.getOnline(false)) { if (all || dev.getStateArray() == null) { count++; devStatusRefresh(dev.getWifiId(), dev.getDeviceId()); } else { Log.e(TAG, \"refresh status has\"); } } } 耗时时长 85s 控制流复杂，for循环嵌套太多 for循环和if嵌套8层 if (false) { for (int i = 0; i cloudRoomList = new ArrayList<>(mCloudFloorsList.get(i).getRoomList()); List cloudRoomList_bk = new ArrayList<>(mCloudFloorsList.get(i).getRoomList()); List acacheRoomList = new ArrayList<>(mACacheFloorsList.get(j).getRoomList()); List acacheRoomList_bk = new ArrayList<>(mACacheFloorsList.get(j).getRoomList()); List bakRoomList = new ArrayList<>(acacheRoomList); List bakRoomList_bk = new ArrayList<>(acacheRoomList); for (int m = 0; m ​ Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-28 19:29:00 var className='atoc';"},"Android/自定义库/":{"url":"Android/自定义库/","title":"自定义库","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/自定义库/上传库到bintray.html":{"url":"Android/自定义库/上传库到bintray.html","title":"上传库到bintray","keywords":"","body":"1.首先创建Library 在Library目录下创建bintray.gradle文件 文件内容如下 apply plugin: 'com.github.dcendents.android-maven' apply plugin: 'com.jfrog.bintray' version = \"0.1.2\" // 修改为你的版本号 def siteUrl = 'https://github.com/h3clikejava/ExtendImageView' // 修改为你的项目的主页 def gitUrl = 'https://github.com/h3clikejava/ExtendImageView.git' // 修改为你的Git仓库的url group = \"com.qiaoshouliang\" // Maven Group ID for the artifact，一般填你唯一的包名 install { repositories.mavenInstaller { // This generates POM.xml with proper parameters pom { project { packaging 'aar' // Add your description here name 'test' //项目描述 url siteUrl // Set your license licenses { license { name 'The Apache Software License, Version 2.0' url 'http://www.apache.org/licenses/LICENSE-2.0.txt' } } developers { developer { id 'qiaoshouliang' //填写的一些基本信息 name 'qiaoshouliang' email 'qiaoshouliang@126.com' } } scm { connection gitUrl developerConnection gitUrl url siteUrl } } } } } task sourcesJar(type: Jar) { from android.sourceSets.main.java.srcDirs classifier = 'sources' } task javadoc(type: Javadoc) { source = android.sourceSets.main.java.srcDirs classpath += project.files(android.getBootClasspath().join(File.pathSeparator)) } task javadocJar(type: Jar, dependsOn: javadoc) { classifier = 'javadoc' from javadoc.destinationDir } artifacts { archives javadocJar archives sourcesJar } Properties properties = new Properties() properties.load(project.rootProject.file('local.properties').newDataInputStream()) bintray { user = properties.getProperty(\"bintray.user\") key = properties.getProperty(\"bintray.apikey\") configurations = ['archives'] pkg { repo = \"maven\" name = \"widget\" //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true } } 2. 在项目根目录build.gradle下加入 dependencies { classpath 'com.android.tools.build:gradle:2.3.3' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.4' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.4.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files } 如图 3. 在local.properties中加入如下两行，用来配置bintray的用户名的APIKey bintray.user=josenqiao bintray.apikey=f1ccb3d650a6b39aeab4d4a0e1ad97f867e52f39 登录Bintray来查看自己的APIKey，在Edit Profile中进行查看 4.在Bintray中创建maven库 Name需要和Pkg中的repo相同 pkg { repo = \"maven\" name = \"widget\" //发布到JCenter上的项目名字 websiteUrl = siteUrl vcsUrl = gitUrl licenses = [\"Apache-2.0\"] publish = true } 5.配置成功之后在项目的根目录下使用命令 ./gradlew clean build bintrayUpload 6. 需要注意的问题 6.1 注册Bintray的时候需要选择For an Open Source Account Sign Up Here ==否则上传的时候无法找到你对应的 repo = 'maven'== 如果是从Start YOUR FREE TRIAL注册的用户，Edit Porfile中没有Repositories这个配置项。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 17:11:20 var className='atoc';"},"Android/Idea插件/":{"url":"Android/Idea插件/","title":"Idea插件","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/Idea插件/发布Idea Plugin.html":{"url":"Android/Idea插件/发布Idea Plugin.html","title":"发布Idea Plugin","keywords":"","body":"网址： https://plugins.jetbrains.com/idea 上传打包生成的jar包 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Idea插件/Editor的使用.html":{"url":"Android/Idea插件/Editor的使用.html","title":"Editor的使用","keywords":"","body":"首先介绍几个对象 CaretModel对象 CaretModel对象用于描述插入光标，通过CaretModel对象，可以实现如下功能： moveToOffset(int offset)：将光标移动到指定位置（offset） getOffset()：获取当前光标位置偏移量 getCaretCount：获取光标数量（可能有多个位置有光标） void addCaretListener(CaretListener listener) ，void removeCaretListener(CaretListener listener)：添加或移除光标监听器（CareListener） Caret addCaret(VisualPosition visualPosition)：加入新的光标 …… SelectionModel对象 SelectionModel对象用于描述光标选中的文本段，通过SelectionModel对象可以实现如下功能： String getSelectedText() ：获取选中部分字符串。 int getSelectionEnd()：获取选中文本段末尾偏移量 int getSelectionStart()：获取选中文本段起始位置偏移量 void setSelection(int start, int end)：设置选中，将staert到end部分设置为选中 void removeSelection()：将选中文本段删除 void addSelectionListener(SelectionListener listener)：添加监听器，用于监听光标选中变化。 void selectLineAtCaret()：将光标所在的行设置为选中。 void selectWordAtCaret(boolean honorCamelWordsSettings):将光标所在的单词设置为选中。honorCamelWordsSettings表示是否驼峰命名分隔，如果为true，则大写字母为单词的边界 …… Document对象 与Editor中的其他对象一样，通过Editor对象的一个getter函数即可得到Document对象： Document document = editor.getDocument(); Document对象用于描述文档文件，通过Document对象可以很方便的对Editor中的文件进行操作。可以做如下这些事情： String getText()、String getText( TextRange range)：获取Document对象对应的文件字符串。 int getTextLength()：获取文件长度。 int getLineCount()：获取文件的行数 int getLineNumber(int offset)：获取指定偏移量位置对应的行号offset取值为[0,getTextLength()-1]。 int getLineStartOffset(int line)：获取指定行的第一个字符在全文中的偏移量，行号的取值范围为：[0,getLineCount()-1] int getLineEndOffset(int line)：获取指定行的最后一个字符在全文中的偏移量，行号的取值范围为：[0,getLineCount()-1] void insertString(int offset, CharSequence s)：在指定偏移位置插入字符串 void deleteString(int startOffset, int endOffset)：删除[startOffset,endOffset]位置的字符串，如果文件为只读，则会抛异常。 void replaceString(int startOffset, int endOffset, CharSequence s)：替换[startOffset,endOffset]位置的字符串为s void addDocumentListener( DocumentListener listener)：添加Document监听器，在Document内容发生变化之前和变化之后都会回调相应函数。 …… 应用实例--在指定位置下添加一个PsiElement 思路如下： 获取选中的文本 获取选中文本所在行末尾的PsiElement 创建一个Log.e(TAG, \"MainActivity \" + log2.toString());的PsiStatement 将这个PsiStatement添加到PsiElement的后边 获取选中的文本 //获取SelectionModel对象 SelectionModel selectionModel = editor.getSelectionModel(); //拿到选中部分字符串 String selectedText = selectionModel.getSelectedText(); 获取选中文本所在行末尾的PsiElement //获取当前所在的行号 int line = editor.getCaretModel().getLogicalPosition().line; EventLogger.log(line+\"\"); Document document = editor.getDocument(); int offset1 = document.getLineEndOffset(line); Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Idea插件/idea 插件打印Event log 方法.html":{"url":"Android/Idea插件/idea 插件打印Event log 方法.html","title":"idea 插件打印Event log 方法","keywords":"","body":"打印 Event log 的方式 方法如下： public class EventLogger { private static final String GROUP_ID = \"Log\";//The unique group id where \"Event Log\" could use to group your messages together. private static final String TITLE = \"Log Event Log\";//The title on Balloon /** * Print log to \"Event Log\" */ public static void log(String msg) { Notification notification = new Notification(GROUP_ID, TITLE, msg, NotificationType.INFORMATION);//build a notification //notification.hideBalloon();//didn't work Notifications.Bus.notify(notification);//use the default bus to notify (application level) Balloon balloon = notification.getBalloon(); if (balloon != null) {//fix: #20 潜在的NPE balloon.hide(true);//try to hide the balloon immediately. } } } 使用方式 EventLogger.log(\"String log = \\\"adsdf \\\";\"); 如下图在Event Log中就打印出Log Event Log: String log = \"adsdf \"; Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Idea插件/Idea 插件开发常用方法.html":{"url":"Android/Idea插件/Idea 插件开发常用方法.html","title":"Idea 插件开发常用方法","keywords":"","body":"创建文件时用到的方法 获取常用工具类 myFactory = JavaPsiFacade.getElementFactory(mProject); 获取鼠标选中的目录 通过AnActionEvent获取到Ideview,然后调用getOrChooseDiretory() 获取鼠标右击选中的目录 IdeView ideView = anActionEvent.getRequiredData(LangDataKeys.IDE_VIEW); PsiDirectory directory = ideView.getOrChooseDirectory(); 创建Java类 通过DirectoryService创建Java类 myDirectoryService = JavaDirectoryService.getInstance(); PsiClass psiClass = myDirectoryService.createClass(directory, \"Text\", JavaTemplateUtil.INTERNAL_CLASS_TEMPLATE_NAME); 设置包名 PsiJavaFile javaFile = (PsiJavaFile) psiClass.getContainingFile(); PsiPackage psiPackage = myDirectoryService.getPackage(directory); javaFile.setPackageName(psiPackage.getQualifiedName()); 设置类的权限 psiClass.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true); psiClass类中添加接口 PsiClass view = myFactory.createInterface(\"View\"); psiClass.add(view); 根据名字全局查找PsiClass private PsiClass getPsiClassByName(String name) { PsiClass[] psiClasses = myShortNamesCache.getClassesByName(name, myProjectScope);//NotNull PsiClass psiClass = null; if (psiClasses.length != 0) {//if the class already exist. psiClass = psiClasses[0]; }//and return psiClass; } 根据PsiFile查找PsiClass if ((psiFile1 instanceof PsiJavaFile) && ((PsiJavaFile) psiFile1).getClasses().length > 0) { psiClass = ((PsiJavaFile) psiFile1).getClasses()[0]; } 手动设置Action的名字和图标 Presentation presentation = getTemplatePresentation(); presentation.setText(fileType); presentation.setIcon(IconLoader.getIcon(\"/icons/icon_tf.png\")); 其中icons要放到Resource目录下： 注意图片的命名规则 在ActionGroup中手动添加Acton public class AddMVPFile extends DefaultActionGroup implements DumbAware { public AddMVPFile() { setPopup(true); Presentation presentation = getTemplatePresentation(); presentation.setText(\"MVPFile\"); presentation.setIcon(IconLoader.getIcon(\"/icons/icon_tf.png\")); List fileTypes = new ArrayList<>(); fileTypes.add(\"Contract\"); fileTypes.add(\"PresenterImpl\"); fileTypes.add(\"ModelImpl\"); for (String fileType:fileTypes){ add(new AddFile(fileType)); } } } 其中AddFile是Acton,要实现如下所示的效果，需要加入 setPopup(true);否则Action是平铺开来的，没办法放到MVPFile下 通过复写Action 的 update 来控制Action是否可见 @Override public void update(AnActionEvent e) { super.update(e); IdeView ideView = e.getRequiredData(LangDataKeys.IDE_VIEW); PsiDirectory directory = ideView.getOrChooseDirectory(); if (directory.getName().equals(\"contract\")) e.getPresentation().setEnabledAndVisible(true); else e.getPresentation().setEnabledAndVisible(false); } e.getPresentation().setEnabled(true);用来设置该Action是否可用, e.getPresentation().setEnabledAndVisible(true);用来设置该Action可用并且可见,可以灵活选用 显示错误信息 Messages.showErrorDialog(\"Generation failed, \" + \"your class name MUST END WITH 'Contract' or 'Presenter'.\", \"Class Name Error\"); Dialog 设置 //设置Dialog的标题 setTitle(\"New Mvp File\"); //设置Dialog的最小大小 setMinimumSize(new Dimension(260, 120)); //设置Dialog在屏幕中间，public void setLocationRelativeTo(Component c)设置窗口相对于指定组件的位置。 //如果组件当前未显示，或者 c 为 null，则此窗口将置于屏幕的中央。 setLocationRelativeTo(null); setLocationRelativeTo（null）可以使其屏幕居中，但如果IDE不全屏，显示的效果就不好看了，想使Dialog在IDE窗口居中显示，可以这样设置： setLocationRelativeTo(WindowManager.getInstance().getFrame(actionEvent.getProject()) 注意setMinimumSize和setLocationRelativeTo的先后位置，如果setLocationRelativeTo在前，则创建出来的窗口的左上角居中，因为这时窗口还没有大小。 导入需要的类 要想使用如下的方法导入import，前提条件是需要导入的类必须包含包名，例如Log.e需要写成android.util.Log.e(TAG,field.toString());： JavaCodeStyleManager styleManager = JavaCodeStyleManager.getInstance(project); styleManager.optimizeImports(file); styleManager.shortenClassReferences(targetClass); 获取PsiElment下所有的PsiStatement for (PsiStatement psiStatement : psiMethod.getBody().getStatements()) { EventLogger.log(psiStatement.getText()); // 查找setContentView if (psiStatement.getFirstChild() instanceof PsiMethodCallExpression) { PsiReferenceExpression methodExpression = ((PsiMethodCallExpression) psiStatement.getFirstChild()).getMethodExpression(); if (methodExpression.getText().equals(\"setContentView\")) { setContentViewStatement = psiStatement; } else if (methodExpression.getText().equals(\"initView\")) { hasInitViewStatement = true; } } } Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Idea插件/idea插件开发.html":{"url":"Android/Idea插件/idea插件开发.html","title":"idea插件开发","keywords":"","body":"VFS简介 虚拟文件系统（VFS）是一个Intellij Platform组件，它封装了大部分对活动文件的处理操作，为了达成以下目的： 提供一个处理文件的通用API，而不关心文件的具体位置（无论文件位于磁盘上、归档文件中还是HTTP服务器上） 追踪文件变化，并且在检测到文件内容发生更改时能提供新旧两个版本的文件 建立文件在VFS和持久化存储之间的关联 为了达到后两个目的，VFS为用户磁盘上的内容管理了一个持久化的快照，快照只存储那些通过VFS API访问过的和被异步更新后发生变化了的文件。快照是应用程序级别而不是工程级别的，也就是说，如果一个文件被多个项目引用，它的内容只会在快照中存在一个副本。所有的VFS访问操作都要经过快照。 如果通过VFS API访问文件时该文件不存在于快照中，VFS将从磁盘中加载该文件并存入快照，然后从快照返回数据。快照中只存储那些可被直接访问的信息，例如一个文本文件的内容会被全部存入快照，而另一些不可被直接访问的内容例如jar文件等，VFS只会存储它的元数据，例如文件名、文件尺寸和时间戳等。快照这一特性意味着IDE中显示的文件系统和文件内容可能并不总是能匹配磁盘上的实际内容。在IDE中，有一个观察者进程会从文件系统中接收到文件更改的通知并通知IDE进行刷新操作，刷新操作基于文件的时间戳，如果文件内容被更改而时间戳维持不变的话IDE将不会更新该文件的内容到快照。 获取VirtualFile 从IOFile获取 假设我们已经有一个位于磁盘上的io.java文件，要将其添加到VFS，可通过如下操作进行： 创建一个File实例File ioFile = new File(\"./io.java\") 将文件从磁盘载入VFSVritualFile virtualFile = LocalFileSystem.getInstance().refreshAndFindFileByIoFile(ioFile) 刷新VFSvirtualFile.refresh(false, true) 其中refresh方法的两个参数分别为是否进行异步刷新和是否进行递归刷新。通过以上代码逻辑即可获得IOFile在VFS中的实例。 使用FileChooser获取 SDK中为我们提供了文件选择组件，通过简单的步骤可以直接获得一个VirtualFile实例： 创建一个FileChooserDescriptor实例，FileChooserDescriptor封装了一组对需要选择的目标文件的特征描述 通过FileChooser.chooseFile()获取VirtualFile实例 从URL获取 VirtualFileManager类提供了findFileByUrl()和refreshAndFindFileByUrl()方法让我们可以从URL获取VirtualFile实例 从VFS获取 IDE所有的文件访问都要通过VFS，上述几种方式最终都是将文件添加到VFS的快照之后再提供访问。当文件已经被快照管理时，可以通过FilenameIndex.getFilesByName()获取到VirtualFile实例。 写入内容到VirtualFile 正如Android不允许在UI线程中进行耗时操作一样，Intellij Platform也不允许在主线程中进行实时的文件写入，而需要通过一个异步任务来进行。 ApplicationManager.getApplication().invokeLater(new Runnable() { @Override public void run() { new WriteCommandAction(project) { @Override protected void run(@NotNull Result result) throws Throwable { //writing to file } }.execute(); } }); 上面是一个写入文件的示例，需要说明的是，WriteCommandAction也并不是实时写入的，如果有多个WriteCommandAction操作，可能会被合并到某一时间同时执行写操作，所以如果在一组WriteCommandAction中有对不同文件的写操作，而该文件在这组操作中是动态获取的，那么最好在写操作执行前先将WriteCommandAction与文件建立一个映射关系。 VFS就介绍到这里，下一篇文章将介绍如何操作工程中的目录、代码和其他资源文件 PSI简介 PSI（Program Structure Interface）是Intellij Platform中一个非常重要的概念，在IDE所管理的Project中，每个目录，Package，源代码和资源文件都会被抽象成相应的PSI对象。本文将以PsiDirectory、PsiJavaFile和XmlFile为例介绍插件对文件目录、Java类和DOM对象的操作。 通用方法 FilenameIndex.getFilesByName()//通过给定名称（不包含具体路径）搜索对应文件 ReferencesSearch.search()//类似于IDE中的Find Usages操作 RefactoringFactory.createRename()//重命名 FileContentUtil.reparseFiles()//通过VirtualFile重建PSI Java专用方法 ClassInheritorsSearch.search()//搜索一个类的所有子类 JavaPsiFacade.findClass()//通过类名查找类 PsiShortNamesCache.getInstance().getClassesByName()//通过一个短名称（例如LogUtil）查找类 PsiClass.getSuperClass()//查找一个类的直接父类 JavaPsiFacade.getInstance().findPackage()//获取Java类所在的Package OverridingMethodsSearch.search()//查找被特定方法重写的方法 使用PSI对象创建一个目录，并在目录中创建一个Java类。 创建目录 //获取Project根目录 PsiDirectory baseDir = PsiDirectoryFactory.getInstance(project).createDirectory(project.getBaseDir()); //递归查找要创建的目录 PsiDirectory subDir = baseDir.findSubdirectory(moduleName); ...... //判断要创建的目录是否已存在 boolean isExist = subDir == null; //如不存在，创建新目录 if(!isExist) { subDir = moduleDir.createSubdirectory(moduleName); } //创建Java类 //创建PsiClass PsiClass clazz = JavaDirectoryService.getInstance().createClass(subDir, className) //添加package字段 ((PsiJavaFile) clazz.getContainingFile()).setPackageName(pkgName); //package字段可通过文件路径解析或使用JavaPsiFacade获得。此处添加字段的操作必须在WriteCommandAction中异步进行。 操作DOM对象 操作从外部读入的DOM 获取XmlFile实例 此处通过FileChooser引导用户从文件系统中选取一个xml文件 FileChooserDescriptor descriptor = new FileChooserDescriptor(true, false, false, false, false, false); VirtualFile virtualFile = FileChooser.chooseFile(descriptor, project, null); if (virtualFile != null) { if (!virtualFile.isDirectory() && virtualFile.getName().endsWith(\"xml\")) { xmlFile = (XmlFile) PsiManager.getInstance(project).findFile(virtualFile); } } //遍历所有深度为1的Tag XmlDocument document = xml.getDocument(); if (document != null) { XmlTag rootTag = document.getRootTag(); if (rootTag != null) { XmlTag[] subTags = rootTag.getSubTags(); for (XmlTag tag : subTags) { //do something you want } } } 生成XmlFile并写入文件 //创建XmlFile XmlFile xmlFile = (XmlFile) PsiFileFactory.getInstance(project).createFileFromText(xmlName, StdFileTypes.XML); //向XmlFile写入属性 XmlDocument document = xmlFile.getDocument(); if (document != null && document.getRootTag() != null) { XmlTag rootTag = document.getRootTag(); rootTag.getAttribute(attrName).setValue(attrValue);//set value for exists attr. rootTag.setAttribute(name,value);//add a new attr and setting value } //写入文件 //写入操作同样需要在WriteCommandAction中异步进行。先判断目标文件是否已存在，如果存在则执行删除 PsiFile psiFile = directory.findFile(xmlName); if (psiFile != null) { psiFile.delete(); } directory.add(file); PSI对象操作就介绍到这里，下篇将介绍PSI的进阶用法 PSI对象操作的进阶用法 使用模板 模板可以大大节省我们编写代码的工作量，在IDEA中，可以通过Preferences -> Editor -> File and Code Templates来查看和编辑已有的模板，或是添加新的模板。在模板中可以使用IDE提供的一些宏变量，常用的有NAME、PACKAGE_NAME、USER、DATE等，在新建模板时也可以使用自定义宏变量，自定义的宏变量将在创建文件时弹出一个输入框让用户对其赋值。 同样的，在插件开发中也可以使用文件模板，将公共部分代码进行抽离，减少创建PSI对象的复杂程度，下面将介绍模板的使用方法。 创建模板 在插件中模板文件必须存放于源文件目录的fileTemplates/internal目录内,模板文件必须以${模板唯一名称}.${对应代码文件的扩展名}.ft命名，例如我们要创建一个java类的模板，命名可能为myTemplate.java.ft，模板文件内也可以使用宏变量，下面我们将创建一个java类通用的模板，包含package字段和类注释。 #if (${PACKAGE_NAME} && ${PACKAGE_NAME} != \"\")package ${PACKAGE_NAME};#end /** * Author: ${USER} * Created on ${DATE} */ public class ${NAME} { } 注册模板 在使用模板前必须先向插件系统注册改模板，编辑plugin.xml文件，在extensions节点加入模板注册信息。 此处的模板名称必须是在IDE内唯一的名称，否则调用模板时会发生冲突。 使用模板 在创建JavaClass时可以调用该模板 PsiClass clazz = JavaDirectoryService.getInstance().createClass(directory, className, templateName); 以上就是模板使用的相关方法，so easy~ 为PsiClass添加类导入、接口实现、成员变量和方法 生成PsiClass后我们可以为其添加一系列Java类的内容，下面介绍各种内容的添加方式，注意，所有的添加操作都必须异步进行。 添加类导入 要为PsiClass导入一个类，那我们必须搜索到这个类在哪，怎么搜索呢，分为两部曲: 创建SearchScope SearchScope是个什么玩意呢，望文生义，它就是用来描述搜索范围的，在这里我们把搜索范围定义为整个Project，IDE会搜索Project内所有的类（包括引用的类库）来寻找目标。 GlobalSearchScope searchScope = GlobalSearchScope.allScope(project); 创建好SearchScope，使用它进行搜索 PsiClass[] psiClasses = PsiShortNamesCache.getInstance(project).getClassesByName(className, searchScope); 搜索完毕之后会返回一个PsiClass数组，包含所有类名匹配的PsiClass，接下来可以过滤出目标类并生成import，同样是两步: 生成PsiImportStatementPsiImportStatement importStatement = psiElementFactory.createImportStatement(psiClass); 添加到PsiClass((PsiJavaFile) clazz.getContainingFile()).getImportList().add(importStatement) 齐活儿~ 添加接口实现 添加接口实现同样需要先搜索接口类，搜索的套路还是和上面类导入的套路一样一样的，我们直接从生成接口字段PsiJavaCodeReferenceElement开始 生成PsiJavaCodeReferenceElementPsiJavaCodeReferenceElement ref = psiElementFactory.createClassReferenceElement(psiClasses); 添加到PsiClass clazz.getImplementsList().add(ref); 需要一提的是添加接口实现声明之后接口类会被自动导入，是不是很Nice~ 添加成员变量 有两个方式为PsiClass添加成员变量 从字符串生成 PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory(); PsiField field = factory.createFieldFromText(\"public int a = 0;\", psiClass); 使用此种方式生成成员必须在字符串中显示指定成员的类型和修饰符，并且需要自行保证无语法错误。 通过Factory生成 PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory(); PsiField field = factory.createField(\"a\",PsiType.INT); field.getModifierList().setModifierProperty(PsiModifier.PUBLIC,true); 明显通过此种方式生成的Field更能保证代码质量，也更符合我们对代码进行面向对象操作的理念。 添加方法 Method同样有通过Text和通过Factory生成两种方式。 通过字符串生成PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory(); PsiMethod method = factory.createMethodFromText(\"public String toString(){}\",psiClass); 通过Factory生成PsiElementFactory factory = JavaPsiFacade.getInstance(project).getElementFactory(); PsiMethod method = factory.createField(\"getCount\",PsiType.INT); 为Method添加注解method.getModifierList().addAnnotation(\"Override\") 同样的，可以为PsiMethod添加修饰符和方法体，添加方式和上文添加成员变量相同。 格式化代码 CodeStyleManager.getInstance(project).reformat(psiClass); 在编辑器中打开 FileEditorManager.getInstance(project).openTextEditor(new OpenFileDescriptor(project, virtualFile), true); 注册自定义类型文件 在编写处理自定义语言或IDE未支持的文件类型时，需要自行注册文件类型到IDE，此处通过一个简单的例子来阐述。 SVG是基于XML，用于描述二维矢量图形的一种图形格式，在IDE中我们可以使用解析标准DOM的方式对其进行解析，通过两个简单步骤即可实现： 添加自定义FileTypeFactory 此处需要新建一个继承了FileTypeFactory的类 public class SVGFileTypeFactory extends FileTypeFactory { @Override public void createFileTypes(FileTypeConsumer fileTypeConsumer) { fileTypeConsumer.consume(XmlFileType.INSTANCE,\"svg\"); } } 2.注册FileTypeFactory 编辑plugin.xml文件，在extensions节点加入 完成以上两个步骤之后就能在IDE中使用XmlFile来描述SVG文件。 Intellij IDEA 插件开发系列到这里就结束了，虽然这样属于黑科技的文章想必也不会有啥人看。 语言结构化支持的角度探究插件开发的相关技巧 这一个系列的前面四篇文章对IntelliJIDEA插件开发的一些基础和通用的方法做了介绍，本篇将会深入一步，从语言结构化支持的角度探究插件开发的相关技巧。 依据Wiki的介绍，编程语言是用来定义计算机程序的形式语言。它是一种被标准化的交流技巧，用来向计算机发出指令。编程语言的描述一般可以分为语法及语义。语法是说明编程语言中，哪些符号或文字的组合方式是正确的，语义则是对于编程的解释。 对语言中语法和语义的分析，就是编译原理里词法分析和语法分析的概念。本篇文章仅会简略介绍针对于完全未知的语言类型的支持，而将更多的重点放在对已有语言类型的继承和扩展支持上。 针对于插件开发者，推荐一个十分有用的插件PsiViewer，可以方便地在IDE内查看编辑器内的内容所对应的PsiElement类型，省去了很多查找文档的操作。 支持未知类型的语言 定义基础语言描述 IDE之所以能仅通过扩展名就能识别出源文件所使用的语言，就是因为IDE内定义的Language和FileType为其提供了支持。 定义Language 简单继承Language类，在构造函数中传入语言ID和其他参数即可。 定义文件类型 继承LanguageFileType类，在实现的方法中分别返回源文件的名称、描述、默认扩展名和Icon即可。 定义FlieTypeFactory 继承FileTypeFactory类，在createFileTypes方法中注册语言，并在plugin.xml的extensions节点中通过fileTypeFactory标签注册Factory。 完成以上几步后IDE便能通过文件扩展名识别出源文件并为其应用图标。 定于词法和语法规范 定义Token和Element 此处定义的Token和Element分别对应于后续词法分析中的Token和IDE内部表示的PsiElement，继承IElementType，完成定义。 定义语法 IDEA支持通过BNF范式来定义语法，按照规则编写一个bnf文件，当语法被定义完成后，可以通过IDE生成PsiElement定义和PSI Parser。 定义Lexer 词法分析器定义了一个文件的内容是如何被分解为Token的，创建Lexer的一个简单的方式是使用JFlex。定义一个lexer规则文件然后通过IDE即可生成Lexer。 实现ParserDefinition接口，创建一个Parser定义，并在plugin.xml中的extensions节点中使用lang.parserDefinition标签注册该parser。 以上便是为语言做最基础支持的步骤，完成文件类型和语法、词法分析器注册后，IDE便能为自定义语言提供文件识别、关键字检查和语法检查等支持。下面结合对weex-language-support插件的开发过程，介绍对扩展了html语法的weex脚本所做的语法高亮、自动提示、Lint等其它一系列的支持的实现。 weex语言支持 识别weex脚本 由于weex脚本文件的结构和html类似，均包括、标签和模板部分，所以我们的Language选择直接继承HTMLLanguage public class WeexFileType extends LanguageFileType { public static final WeexFileType INSTANCE = new WeexFileType(); private WeexFileType() { super(HTMLLanguage.INSTANCE); } //………… } 定义完FileType之后，还需要实现一个对应的FileTypeFactory： public class WeexFileTypeFactory extends FileTypeFactory { @Override public void createFileTypes(@NotNull FileTypeConsumer fileTypeConsumer) { fileTypeConsumer.consume(WeexFileType.INSTANCE); } } 最后在plugin.xml内注册 完成这一步之后，IDE便能正确将以we作为扩展名的文件识别为weex文件，因为继承了HTMLLanguage，html语言原有的js和css的自动补全和lint规则也将被一并继承过来。 支持Weex DSL weex定义了一系列的DSL规则，包括自定义标签、自定义标签属性和数据绑定支持等，接下来我们一步步对这些特性进行支持 自定义标签支持 要让IDE能正确识别自定义的标签（如、等）并对其应用正确的补全和lint规则，我们需要实现自定义的XmlTagNameProvider和XmlElementDescriptorProvider，其中XmlTagNameProvider定义了所能提供的标签的列表，XmlElementDescriptorProvider定义了每个标签的详情。 定义一个WeexTagNameProvider，实现XmlTagNameProvider和XmlElementDescriptorProvider接口： XmlTagNameProvider @Override public void addTagNameVariants(List list, @NotNull XmlTag xmlTag, String prefix) { if (!(xmlTag instanceof HtmlTag)) { return; } Set tags = getWeexTagNames(); for (String s : tags) { LookupElement element = LookupElementBuilder .create(s) .withInsertHandler(XmlTagInsertHandler.INSTANCE) .withBoldness(true) .withIcon(WeexIcons.TYPE) .withTypeText(\"weex component\"); list.add(element); } 如此在输入标签的时候IDE就能将weex标签加入自动补全列表中。 XmlElementDescriptorProvider @Nullable @Override public XmlElementDescriptor getDescriptor(XmlTag xmlTag) { PsiFile declare = getDeclare(xmlTag); return new WeexTagDescriptor(xmlTag.getName(), declare); } 此处的关键是如何将XmlTag与它的声明文件即PsiFile关联起来，此处的桥梁就是XmlElementDescriptor。创建一个实现了XmlElementDescriptor的类，在getDeclaration()方法中返回PsiFile对象，如此便能在执行Open Declaeation的时候跳转到该tag的声明文件内。 在某些时候，我们的声明文件可能并不是位于某个确定位置的目录内，而是处于归档文件中，此处演示如何从一个jar归档中获取PsiFile的引用： public void findPsiFileFromJar(String jarPath, String targetName) { VirtualFile vf = JarFileSystem.getInstance().findLocalVirtualFileByPath(jarPath); VirtualFile target = vf.findChild(targetName); PsiFile declare = PsiManager.getInstance(ProjectUtil.guessProjectForFile(target)).findFile(target); } 最后，为了应用上述实现的功能，需要在plugin.xml中进行注册： 自定义标签属性支持 按照上面的套路，大家肯定能想到标签属性也是有相应的Provider支持的，它就是XmlAttributeDescriptorsProvider，创建相应的实现类，实现以下方法： getAttributeDescriptors(XmlTag xmlTag) 该方法需要返回XmlTag对应的所有属性的Descriptor列表 getAttributeDescriptor(String s, XmlTag xmlTag) 该方法返回名为s的XmlTag所对应的单个Descriptor 此处的Descriptor为XmlAttributeDescriptor实例，描述了每个标签属性的信息，创建实现类，实现以下关键方法： getName() 返回要匹配的属性名称 isEnumerated() 判断属性值是否是枚举属性 getEnumeratedValues() 如果属性值是可枚举的，此处返回所有可能的属性值 同样地，最后需要在plugin.xml中进行注册： 自动补全支持 事实上上文所述的标签支持和标签属性支持已经为IDE提供了部分补全所需的支持，例如在输入标签名称和标签属性名时，IDE已经能根据我们提供的Provider和Descriptor提供一些上下文无关的补全提示，接下来我们来提供与上下文相关的补全支持。 Weex使用双大括号的方式来绑定script中声明的变量，所以我们需要先对script进行分析，得到其中声明的所有变量的函数。此处暂且不对分析JavaScript语言结构进行深入解读，后续有时间单独作文。 需要补充的一点是，为了让插件支持html语法，需要在plugin.xml中声明对语言模块的依赖： com.intellij.modules.xml com.intellij.modules.lang JavaScript 并不是所有IDE都包含JavaScript模块，本插件开发过程中选择IDEA 15作为SDK，并手动将/Applications/IntelliJ IDEA 15.app/Contents/plugins/JavaScriptLanguage目录下的jar文件添加到Project Structure的Classpath中。 言归正传，下面开始介绍如何对标签属性值进行自动补全支持。事实上很简单：一个关键的类CompletionContributor 创建一个继承了CompletionContributor的类，在构造函数中调用extend()方法添加补全的相关逻辑： extend(@Nullable CompletionType type, @NotNull ElementPattern place, CompletionProvider provider) CompleteType 定义补全类型，此处传入CompletionType.BASIC即可。 ElementPattern 定义补全操作需要匹配的目标Element类型，简单来说就是指定在何处该出发自动补全，此处可传入PlatformPatterns.psiElement(XmlAttributeValue.class)，表示在键入标签属性值时触发补全逻辑。 CompletionProvider 补全逻辑真正的Provider。 创建我们自己的CompletionProvider，实现addCompletions方法： protected void addCompletions(@NotNull CompletionParameters completionParameters, ProcessingContext processingContext, @NotNull CompletionResultSet resultSet) { if (completionParameters.getPosition().getContext() instanceof XmlAttributeValue) { final XmlAttributeValue value = (XmlAttributeValue) completionParameters.getPosition().getContext(); for (String s : getCandidateValues(value)) { resultSet.addElement(LookupElementBuilder.create(\"{{\" + s + \"}}\") .withLookupString(s) //匹配查找的字符串 .withIcon(WeexIcons.TYPE) //候选列表中显示的icon .withInsertHandler(new InsertHandler() { @Override public void handleInsert(InsertionContext insertionContext, LookupElement lookupElement) { performInsert(value, insertionContext, lookupElement); } }) // 插入补全内容时的Handler .withBoldness(true) //加粗 } } } 如此就可以在输入标签属性值的时候触发补全逻辑，此处的难点在于如何从js中分析出函数和变量名，并分析出变量的类型和标签属性值的类型是否匹配，处于篇幅限制并未详细解释，如果想了解可以查看weex-language-support的源码或向我咨询。 最后，在plugin.xml中进行注册： CompletionContributor不能支持情况下的补全 在编写weex插件的过程中，发现CompletionContributor并不能在键入标签内容时触发补全（即的情况），为了支持该种情况下的补全，我们想到了一个tricky的办法：Intention IDEA可以帮助你处理一些代码中可能导致错误的情况，当分析出可能存在问题时，IDEA为提供一个Intention列表，包含一些建议实施的修复或改进的行为。在OSX上，默认可以通过Command + Enter触发Intention。 创建一个PsiElementBaseIntentionAction，实现以下关键方法： isAvailable(@NotNull Project project, Editor editor, @NotNull PsiElement element) 判断当前活动的Element（光标所在Element）处是否可以激活Intention，其中project、editor参数为当前的Project和当前活动的编辑器对象。 invoke(@NotNull final Project project, final Editor editor, @NotNull PsiElement element) 用户触发Intention后需要需要执行的逻辑 在此处我们依旧获取了js中导出的所有变量，并创建了一个多级下拉框来供用户选择需要插入的变量值。顺带稍微介绍一下IDEA内置的一系列魔改Swing控件，这些控件大部分以JB开头，例如JBTable，JBColor等，编写插件时使用这些控件能保持与IDE一致的外观风格，让插件没有违和感。此处我们使用ListPopup控件来实现选择列表，通过JBPopupFactory.getInstance().createListPopup可以获得相应的ListPopup实例，并且可以调用ListPopop#showInBestPositionFor方法让ListPopup显示在屏幕上最恰当的位置（光标附近）。 还是一样的步骤，往plugin.xml中注册Intention： com.taobao.weex.intention.TagTextIntention Weex WeexTagTextCompletion Lint Lint是IDE所必须具备的另一项能力，在代码编写阶段，通过分析上下文，找出可能存在的错误或可改进的写法，对用户进行提示，在IDE中，我们熟悉的红色错误下划线，黄色警告下划线都是由Annotator来实现的。创建Annotator的实例，实现annotate方法 annotate(@NotNull PsiElement psiElement, @NotNull AnnotationHolder annotationHolder) 其中psiElement是等待进行检查的元素 创建Annotation Annotation分为Error、Warning、WeakWarning、Info几个级别，对应编辑器中呈现出的各种不同的下划线颜色。使用AnnotationHolder#createXXXAnnotation方法可以创建一个Annotation实例。 附加QuickFix 如上文所述，IDE可以提供一个Intention列表来提供一些建议执行的修复或优化行为，在Annotation中可以通过registerFix()方法来附加一个修复动作。 Find Usages 终于快要写完了…… 查找某个变量在工程中的引用是对这个变量执行重构的前提，插件中通过PsiReferenceContributor和PsiReference为引用分析提供支持。 创建一个继承了PsiReferenceContributor的实例，在registerReferenceProviders方法中处理引用查找。 @Override public void registerReferenceProviders(@NotNull PsiReferenceRegistrar psiReferenceRegistrar) { psiReferenceRegistrar.registerReferenceProvider( XmlPatterns.xmlTag().withLanguage(HTMLLanguage.INSTANCE) .andNot(XmlPatterns.xmlTag().withLocalName(\"script\")) //仅在标签内查找 .andNot(XmlPatterns.xmlTag().withLocalName(\"style\")), new PsiReferenceProvider() { @NotNull @Override public PsiReference[] getReferencesByElement(@NotNull PsiElement psiElement, @NotNull ProcessingContext processingContext) { if (psiElement instanceof XmlTag) { if (((XmlTag) psiElement).getSubTags().length == 0) { String text = ((XmlTag) psiElement).getValue().getText(); if (WeexFileUtil.containsMustacheValue(text)) { List references = new ArrayList(); Map vars = WeexFileUtil.getVars(text); for (Map.Entry entry : vars.entrySet()) { if (WeexFileUtil.getAllVarNames(psiElement).keySet().contains(entry.getKey())) { references.add(new DataReference((XmlTag) psiElement, entry.getValue(), entry.getKey())); } } return references.toArray(new PsiReference[references.size()]); } } } return new PsiReference[0]; } } ); } 最后在plugin.xml中注册： Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Kotlin/":{"url":"Android/Kotlin/","title":"Kotlin","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/Kotlin/Kotlin语法.html":{"url":"Android/Kotlin/Kotlin语法.html","title":"Kotlin语法","keywords":"","body":"List 中扩展函数 joinToString Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-23 14:00:10 var className='atoc';"},"Android/Kotlin/run、apply、let、also、with的用法和区别.html":{"url":"Android/Kotlin/run、apply、let、also、with的用法和区别.html","title":"run、apply、let、also、with的用法和区别","keywords":"","body":"run 用法1 函数定义： public inline fun run(block: () -> R): R = block() 功能：调用run函数块。返回值为函数块最后一行，或者指定return表达式。 示例： val a = run { println(\"run\") return@run 3 } println(a) 运行结果： run 3 用法2 函数定义： public inline fun T.run(block: T.() -> R): R = block() 功能：调用某对象的run函数，在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式。 示例： val a = \"string\".run { println(this) 3 } println(a) 运行结果： string 3 apply 函数定义： public inline fun T.apply(block: T.() -> Unit): T { block(); return this } 功能：调用某对象的apply函数，在函数块内可以通过 this 指代该对象。返回值为该对象自己。 示例： val a = \"string\".apply { println(this) } println(a) 运行结果： string string let 函数定义： `public inline fun T.let(block: (T) -> R): R = block(this 功能：调用某对象的let函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为函数块的最后一行或指定return表达式。 示例： val a = \"string\".let { println(it) 3 } println(a) 运行结果： string 3 also 函数定义（Kotlin1.1新增的）： public inline fun T.also(block: (T) -> Unit): T { block(this); return this } 功能：调用某对象的also函数，则该对象为函数的参数。在函数块内可以通过 it 指代该对象。返回值为该对象自己。 示例： val a = \"string\".also { println(it) } println(a) 运行结果： string string with 函数定义： public inline fun with(receiver: T, block: T.() -> R): R = receiver.block() 功能：with函数和前面的几个函数使用方式略有不同，因为它不是以扩展的形式存在的。它是将某对象作为函数的参数，在函数块内可以通过 this 指代该对象。返回值为函数块的最后一行或指定return表达式。 示例： val a = with(\"string\") { println(this) 3 } println(a) 运行结果： string 3 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/":{"url":"Android/Android知识点/","title":"Android知识点","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/Android知识点/获取WIFI的IP地址.html":{"url":"Android/Android知识点/获取WIFI的IP地址.html","title":"获取WIFI的IP地址","keywords":"","body":"获取WiFi IP 的方法如下： private String getLocalIpAddress() { //获取wifi服务 WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE); //判断wifi是否开启 if (!wifiManager.isWifiEnabled()) { wifiManager.setWifiEnabled(true); } WifiInfo wifiInfo = wifiManager.getConnectionInfo(); int ipAddress = wifiInfo.getIpAddress(); return intToIp(ipAddress); } private String intToIp(int i) { return (i & 0xFF) + \".\" + ((i >> 8) & 0xFF) + \".\" + ((i >> 16) & 0xFF) + \".\" + (i >> 24 & 0xFF); } 需要注意的是 WifiManager wifiManager = (WifiManager) getApplicationContext().getSystemService(WIFI_SERVICE); ==WiFiManager 需要用Application context来获取，否则会报如下错误== Error:(199) Error: The WIFI_SERVICE must be looked up on the Application context or memory will leak on devices Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/引用总结.html":{"url":"Android/Android知识点/引用总结.html","title":"引用总结","keywords":"","body":"Java/Android引用类型及其使用分析 Java/Android中有四种引用类型，分别是： Strong reference - 强引用 Soft Reference - 软引用 Weak Reference - 弱引用 Phantom Reference - 虚引用 不同的引用类型有着不同的特性，同时也对应着不同的使用场景。 Strong reference - 强引用 实际编码中最常见的一种引用类型。常见形式如：A a = new A();等。强引用本身存储在栈内存中，其存储指向对内存中对象的地址。一般情况下，当对内存中的对象不再有任何强引用指向它时，垃圾回收机器开始考虑可能要对此内存进行的垃圾回收。如当进行编码：a = null，此时，刚刚在堆中分配地址并新建的a对象没有其他的任何引用，当系统进行垃圾回收时，堆内存将被垃圾回收。 SoftReference、WeakReference、PhantomReference都是类java.lang.ref.Reference的子类。Reference作为抽象基类，定义了其子类对象的基本操作。Reference子类都具有如下特点： 1.Reference子类不能无参化直接创建，必须至少以强引用对象为构造参数，创建各自的子类对象； 2.因为1中以强引用对象为构造参数创建对象，因此，使得原本强引用所指向的堆内存中的对象将不再只与强引用本身直接关联，与Reference的子类对象的引用也有一定联系。且此种联系将可能影响到对象的垃圾回收。 根据不同的子类对象对其指示对象（强引用所指向的堆内存中的对象）的垃圾回收不同的影响特点，分别形成了三个子类，即SoftReference、WeakReference和PhantomReference。 Soft Reference - 软引用 软引用的一般使用形式如下： A a = new A(); SoftReference srA = new SoftReference(a); 通过对象的强引用为参数，创建了一个SoftReference对象，并使栈内存中的wrA指向此对象。 此时，进行如下编码：a = null，对于原本a所指向的A对象的垃圾回收有什么影响呢？ 先直接看一下下面一段程序的输出结果： import java.lang.ref.SoftReference; public class ReferenceTest { public static void main(String[] args) { A a = new A(); SoftReference srA = new SoftReference(a); a = null; if (srA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + srA.get()); } // 垃圾回收 System.gc(); if (srA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + srA.get()); } } } class A { } 输出结果为： 1 a对象尚未被回收A@4807ccf6 2 a对象尚未被回收A@4807ccf6 当 a = null后，堆内存中的A对象将不再有任何的强引用指向它，但此时尚存在srA引用的对象指向A对象。当第一次调用srA.get()方法返回此指示对象时，由于垃圾回收器很有可能尚未进行垃圾回收，此时get()是有结果的，这个很好理解。当程序执行System.gc();强制垃圾回收后，通过srA.get()，发现依然可以得到所指示的A对象，说明A对象并未被垃圾回收。 那么，软引用所指示的对象什么时候才开始被垃圾回收呢？需要满足如下两个条件： 当其指示的对象没有任何强引用对象指向它； 当虚拟机内存不足时。 因此，SoftReference变相的延长了其指示对象占据堆内存的时间，直到虚拟机内存不足时垃圾回收器才回收此堆内存空间。 Weak Reference - 弱引用 同样的，软引用的一般使用形式如下： A a = new A(); WeakReference wrA = new WeakReference(a); 当没有任何强引用指向此对象时， 其垃圾回收又具有什么特性呢？ import java.lang.ref.WeakReference; public class ReferenceTest { public static void main(String[] args) { A a = new A(); WeakReference wrA = new WeakReference(a); a = null; if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } // 垃圾回收 System.gc(); if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } } } class A { } 输出结果为： a对象尚未被回收A@52e5376a a对象进入垃圾回收流程 输出的第一条结果解释同上。当进行垃圾回收后，wrA.get()将返回null，表明其指示对象进入到了垃圾回收过程中。因此，对弱引用特点总结为： WeakReference不改变原有强引用对象的垃圾回收时机，一旦其指示对象没有任何强引用对象时，此对象即进入正常的垃圾回收流程。 那么，依据此特点，很可能有疑问：WeakReference存在又有什么意义呢？ 其主要使用场景见于：==当前已有强引用指向强引用对象，此时由于业务需要，需要增加对此对象的引用，同时又不希望改变此引用的垃圾回收时机，此时WeakReference正好符合需求，常见于一些与生命周期的场景中==。 下面给出一个Android中关于WeakReference使用的场景 结合静态内部类和WeakReference来解决Activity中可能存在的Handler内存泄露问题。 Activity中我们需要新建一个线程获取数据，使用handler - sendMessage方式。下面是这一过程的一般性代码： public class MainActivity extends Activity { //... private int page; private Handler handler = new Handler() { @Override public void handleMessage(Message msg) { if (msg.what == 1) { //... page++; } else { //... } }; }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //... new Thread(new Runnable() { @Override public void run() { //.. Message msg = Message.obtain(); msg.what = 1; //msg.obj = xx; handler.sendMessage(msg); } }).start(); //... } } 在Eclispe中Run Link，将会看到警示信息：This Handler class should be static or leaks might occur ...点击查看此信息，其详情中对问题进行了说明并给出了建议性的解决方案。 Issue: Ensures that Handler classes do not hold on to a reference to an outer class Id: HandlerLeak Since this Handler is declared as an inner class, it may prevent the outer class from being garbage collected. If the Handler is using a Looper or MessageQueue for a thread other than the main thread, then there is no issue. If the Handler is using the Looper or MessageQueue of the main thread, you need to fix your Handler declaration, as follows: Declare the Handler as a static class;In the outer class, instantiate a WeakReference to the outer class and pass this object to your Handler when you instantiate the Handler; Make all references to members of the outer class using the WeakReference object. 大致的意思是建议将Handler定义成内部静态类，并在此静态内部类中定义一个WeakReference的引用，由于指示外部的Activity对象。 问题分析： Activity具有自身的生命周期，Activity中新开启的线程运行过程中，可能此时用户按下了Back键，或系统内存不足等希望回收此Activity，由于Activity中新起的线程并不会遵循Activity本身的什么周期，也就是说，当Activity执行了onDestroy,由于线程以及Handler 的HandleMessage的存在，使得系统本希望进行此Activity内存回收不能实现，因为非静态内部类中隐性的持有对外部类的引用，导致可能存在的内存泄露问题。 ==因此，在Activity中使用Handler时，一方面需要将其定义为静态内部类形式，这样可以使其与外部类（Activity）解耦，不再持有外部类的引用，同时由于Handler中的handlerMessage一般都会多少需要访问或修改Activity的属性，此时，需要在Handler内部定义指向此Activity的WeakReference，使其不会影响到Activity的内存回收同时，可以在正常情况下访问到Activity的属性==。 Google官方给出的建议写法为： public class MainActivity extends Activity { //... private int page; private MyHandler mMyHandler = new MyHandler(this); private static class MyHandler extends Handler { private WeakReference wrActivity; public MyHandler(MainActivity activity) { this.wrActivity = new WeakReference(activity); } @Override public void handleMessage(Message msg) { if (wrActivity.get() == null) { return; } MainActivity mActivity = wrActivity.get(); if (msg.what == 1) { //... mActivity.page++; } else { //... } } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //... new Thread(new Runnable() { @Override public void run() { //.. Message msg = Message.obtain(); msg.what = 1; //msg.obj = xx; mMyHandler.sendMessage(msg); } }).start(); //... } } 对于SoftReference和WeakReference，还有一个构造器参数为ReferenceQueue，当SoftReference或WeakReference所指示的对象确实被垃圾回收后，其引用将被放置于ReferenceQueue中。注意上文中，当SoftReference或WeakReference的get()方法返回null时，仅是表明其指示的对象已经进入垃圾回收流程，此时对象不一定已经被垃圾回收。而只有确认被垃圾回收后，如果ReferenceQueue，其引用才会被放置于ReferenceQueue中。 看下面的一个例子： public class ReferenceTest { public static void main(String[] args) { A a = new A(); WeakReference wrA = new WeakReference(a); a = null; if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } // 垃圾回收 System.gc(); if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } } } class A { @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"in A finalize\"); } } 输出结果为： 1 a对象尚未被回收A@46993aaa 2 a对象被回收 3 in A finalize 由此，也验证了上文中的“进入垃圾回收流程”的说法。下面结合ReferenceQueue，看一段代码： public class ReferenceTest { public static void main(String[] args) { A a = new A(); ReferenceQueue rq = new ReferenceQueue(); WeakReference wrA = new WeakReference(a, rq); a = null; if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } System.out.println(\"rq item:\" + rq.poll()); // 垃圾回收 System.gc(); if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } /* try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } */ System.out.println(\"rq item:\" + rq.poll()); } } class A { @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"in A finalize\"); } } 输出结果为： 1 a对象尚未被回收A@302b2c81 2 rq item:null 3 a对象进入垃圾回收流程 4 rq item:null 5 in A finalize 由此，验证了“仅进入垃圾回收流程的SoftReference或WeakReference引用尚未被加入到ReferenceQueue”。 public class ReferenceTest { public static void main(String[] args) { A a = new A(); ReferenceQueue rq = new ReferenceQueue(); WeakReference wrA = new WeakReference(a, rq); a = null; if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } System.out.println(\"rq item:\" + rq.poll()); // 垃圾回收 System.gc(); if (wrA.get() == null) { System.out.println(\"a对象进入垃圾回收流程\"); } else { System.out.println(\"a对象尚未被回收\" + wrA.get()); } try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"rq item:\" + rq.poll()); } } class A { @Override protected void finalize() throws Throwable { super.finalize(); System.out.println(\"in A finalize\"); } } 输出结果为： 1 a对象尚未被回收A@6276e1db 2 rq item:null 3 a对象进入垃圾回收流程 4 in A finalize 5 rq item:java.lang.ref.WeakReference@645064f 由此，证实了上述说法。 PhantomReference - 虚引用 与SoftReference或WeakReference相比，PhantomReference主要差别体现在如下几点： PhantomReference只有一个构造函数PhantomReference(T referent, ReferenceQueue q)，因此，PhantomReference使用必须结合ReferenceQueue； 不管有无强引用指向PhantomReference的指示对象，PhantomReference的get()方法返回结果都是null。 public class ReferenceTest { public static void main(String[] args) { A a = new A(); ReferenceQueue rq = new ReferenceQueue(); PhantomReference prA = new PhantomReference(a, rq); System.out.println(\"prA.get():\" + prA.get()); a = null; System.gc(); try { Thread.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"rq item:\" + rq.poll()); } } class A { } 输出结果为： 1 prA.get():null 2 rq item:java.lang.ref.PhantomReference@1da12fc0 代码中的Thread.sleep(1);作用与上例中相同，都是确保垃圾回收线程能够执行。否则，进进入垃圾回收流程而没有真正被垃圾回收的指示对象的虚引用是不会被加入到PhantomReference中的。 与WeakReference相同，PhantomReference并不会改变其指示对象的垃圾回收时机。且可以总结出：ReferenceQueue的作用主要是用于监听SoftReference/WeakReference/PhantomReference的指示对象是否已经被垃圾回收。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/自定义 Live Templates.html":{"url":"Android/Android知识点/自定义 Live Templates.html","title":"自定义 Live Templates","keywords":"","body":"先举个例子，我们在 Android 开发中输入 Toast ，然后会有如下如下的快速操作： 现在我们创建一个自定义的Live Template 设置 -> Editor -> Live Templates ，点击右上角的 + 号，选择 Template Group ，因为我习惯自定义的单独分组先，这样好管理，比如新建一个分组叫做 stormzhang ，然后就会看到有一个 stormzhang 的分组显示在了列表里，这时候鼠标选中该分组，然后再点击右上角的 + 号，点击 Live Template ，然后如下图填写缩写与描述，紧接着把如下代码拷贝到下面的输入框里（PS：单例模式的写法有很多种，这里就随意以其中一种为例） private static $CLASS$ instance = null; private $CLASS$(){} public static $CLASS$ getInstance() { synchronized ($CLASS$.class) { if (instance == null) { instance = new $CLASS$(); } } return instance; } 注意这里，如果你这段代码是一些固定的代码，那么至此就结束了，但是这段代码里是动态的，里面有一些变量，因为每个类的类名如果都需要自己手动更改就太麻烦了，所以有个变量 $CLASS$ ，所以需要点击下面的 Define ，先要定义变量所属的语言范围，点开之后可以看到这里支持 HTML、XML、JSON、Java、C++ 等，很明显，我们这里需要支持 Java ，选择选中 Java : 紧接着，我们需要给变量 $CLASS$ 定义类型，这里的 CLASS 名字随意取的，为了可读性而已，你高兴可以取名 abc ，真正给这个变量定义类型的是点击 Edit variables 按钮，来对该变量进行编辑，我们选择 calssName() 选项，可以看到还有其他选项，但是看名字大家大概就猜到什么含义了，这里就不一一解释了。 点击 ok 保存，至此我们定义的一个单例的 Live Template 就完成了。你可以随意打开一个类文件，然后输入 singleton 按 tab 或者 enter 键就可以看到神奇的一幕出现了，是不是很帅？ Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/Android 内存泄漏总结.html":{"url":"Android/Android知识点/Android 内存泄漏总结.html","title":"Android 内存泄漏总结","keywords":"","body":"Android 内存泄漏总结 摘要： Android 内存泄漏总结 内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一 Android 内存泄漏总结 内存管理的目的就是让我们在开发中怎么有效的避免我们的应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。最近自己阅读了大量相关的文档资料，打算做个 总结 沉淀下来跟大家一起分享和学习，也给自己一个警示，以后 coding 时怎么避免这些情况，提高应用的体验和质量。 我会从 java 内存泄漏的基础知识开始，并通过具体例子来说明 Android 引起内存泄漏的各种原因，以及如何利用工具来分析应用内存泄漏，最后再做总结。 篇幅有些长，大家可以分几节来看！ Java 内存分配策略 Java 程序运行时的内存分配策略有三种,分别是静态分配,栈式分配,和堆式分配，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。 静态存储区（方法区）：主要存放静态数据、全局 static 数据和常量。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。 栈区 ：当方法被执行时，方法体内的局部变量都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会自动被释放。因为栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 堆区 ： 又称动态内存分配，通常就是指在程序运行时直接 new 出来的内存。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。 栈与堆的区别： 在方法体内定义的（局部变量）一些基本类型的变量和对象的引用变量都是在方法的栈内存中分配的。当在一段方法块中定义一个变量时，Java 就会在栈中为该变量分配内存空间，当超过该变量的作用域后，该变量也就无效了，分配给它的内存空间也将被释放掉，该内存空间可以被重新使用。 堆内存用来存放所有由 new 创建的对象（包括该对象其中的所有成员变量）和数组。在堆中分配的内存，将由 Java 垃圾回收器来自动管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，这个特殊的变量就是我们上面说的引用变量。我们可以通过这个引用变量来访问堆中的对象或者数组。 举个例子: public class Sample() { int s1 = 0; Sample mSample1 = new Sample(); public void method() { int s2 = 1; Sample mSample2 = new Sample(); } } Sample mSample3 = new Sample(); Sample 类的局部变量 s2 和引用变量 mSample2 都是存在于栈中，但 mSample2 指向的对象是存在于堆上的。 mSample3 指向的对象实体存放在堆上，包括这个对象的所有成员变量 s1 和 mSample1，而它自己存在于栈中。 结论： 局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。 成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。 了解了 Java 的内存分配之后，我们再来看看 Java 是怎么管理内存的。 Java是如何管理内存 Java的内存管理就是对象的分配和释放问题。在 Java 中，程序员需要通过关键字 new 为每个对象申请内存空间 (基本类型除外)，所有的对象都在堆 (Heap)中分配空间。另外，对象的释放是由 GC 决定和执行的。在 Java 中，内存的分配是由程序完成的，而内存的释放是由 GC 完成的，这种收支两条线的方法确实简化了程序员的工作。但同时，它也加重了JVM的工作。这也是 Java 程序运行速度较慢的原因之一。因为，GC 为了能够正确释放对象，GC 必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC 都需要进行监控。 监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。 为了更好理解 GC 的工作原理，我们可以将对象考虑为有向图的顶点，将引用关系考虑为图的有向边，有向边从引用者指向被引对象。另外，每个线程对象可以作为一个图的起始顶点，例如大多程序从 main 进程开始执行，那么该图就是以 main 进程顶点开始的一棵根树。在这个有向图中，根顶点可达的对象都是有效对象，GC将不回收这些对象。如果某个对象 (连通子图)与这个根顶点不可达(注意，该图为有向图)，那么我们认为这个(这些)对象不再被引用，可以被 GC 回收。 以下，我们举一个例子说明如何用有向图表示内存管理。对于程序的每一个时刻，我们都有一个有向图表示JVM的内存分配情况。以下右图，就是左边程序运行到第6行的示意图。 Java使用有向图的方式进行内存管理，可以消除引用循环的问题，例如有三个对象，相互引用，只要它们和根进程不可达的，那么GC也是可以回收它们的。这种方式的优点是管理内存的精度很高，但是效率较低。另外一种常用的内存管理技术是使用计数器，例如COM模型采用计数器方式管理构件，它与有向图相比，精度行低(很难处理循环引用的问题)，但执行效率很高。 什么是Java中的内存泄露 在Java中，内存泄漏就是存在一些被分配的对象，这些对象有下面两个特点，首先，这些对象是可达的，即在有向图中，存在通路可以与其相连；其次，这些对象是无用的，即程序以后不会再使用这些对象。如果对象满足这两个条件，这些对象就可以判定为Java中的内存泄漏，这些对象不会被GC所回收，然而它却占用内存。 在C++中，内存泄漏的范围更大一些。有些对象被分配了内存空间，然后却不可达，由于C++中没有GC，这些内存将永远收不回来。在Java中，这些不可达的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。 通过分析，我们得知，对于C++，程序员需要自己管理边和顶点，而对于Java程序员只需要管理边就可以了(不需要管理顶点的释放)。通过这种方式，Java提高了编程的效率。 因此，通过以上分析，我们知道在Java中也有内存泄漏，但范围比C++要小一些。因为Java从语言上保证，任何对象都是可达的，所有的不可达对象都由GC管理。 对于程序员来说，GC基本是透明的，不可见的。虽然，我们只有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义， 该函数不保证JVM的垃圾收集器一定会执行。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。 同样给出一个 Java 内存泄漏的典型例子， Vector v = new Vector(10); for (int i = 1; i 在这个例子中，我们循环申请Object对象，并将所申请的对象放入一个 Vector 中，如果我们仅仅释放引用本身，那么 Vector 仍然引用该对象，所以这个对象对 GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从 Vector 中删除，最简单的方法就是将 Vector 对象设置为 null。 Android中常见的内存泄漏汇总 集合类泄漏 集合类如果仅仅有添加元素的方法，而没有相应的删除机制，导致内存被占用。如果这个集合类是全局性的变量 (比如类中的静态属性，全局性的 map 等即有静态引用或 final 一直指向它)，那么没有相应的删除机制，很可能导致集合所占用的内存只增不减。比如上面的典型例子就是其中一种情况，当然实际上我们在项目中肯定不会写这么 2B 的代码，但稍不注意还是很容易出现这种情况，比如我们都喜欢通过 HashMap 做一些缓存之类的事，这种情况就要多留一些心眼。 单例造成的内存泄漏 由于单例的静态特性使得其生命周期跟应用的生命周期一样长，所以如果使用不恰当的话，很容易造成内存泄漏。比如下面一个典型的例子， public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context; } public static AppManager getInstance(Context context) { if (instance == null) { instance = new AppManager(context); } return instance; } } 这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个Context，所以这个Context的生命周期的长短至关重要： 1、如果此时传入的是 Application 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。 2、如果此时传入的是 Activity 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。 正确的方式应该改为下面这种方式： public class AppManager { private static AppManager instance; private Context context; private AppManager(Context context) { this.context = context.getApplicationContext();// 使用Application 的context } public static AppManager getInstance(Context context) { if (instance == null) { instance = new AppManager(context); } return instance; } } 或者这样写，连 Context 都不用传进来了： 在你的 Application 中添加一个静态方法，getContext() 返回 Application 的 context， ... context = getApplicationContext(); ... /** * 获取全局的context * @return 返回全局context对象 */ public static Context getContext(){ return context; } public class AppManager { private static AppManager instance; private Context context; private AppManager() { this.context = MyApplication.getContext();// 使用Application 的context } public static AppManager getInstance() { if (instance == null) { instance = new AppManager(); } return instance; } } 匿名内部类/非静态内部类和异步线程 非静态内部类创建静态实例造成的内存泄漏 有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，可能会出现这种写法： ``` public class MainActivity extends AppCompatActivity { private static TestResource mResource = null; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mManager == null){ mManager = new TestResource(); } //... } class TestResource { //... } } ``` 这样就在Activity内部创建了一个非静态内部类的单例，每次启动Activity时都会使用该单例的数据，这样虽然避免了资源的重复创建，不过这种写法却会造成内存泄漏，因为非静态内部类默认会持有外部类的引用，而该非静态内部类又创建了一个静态的实例，该实例的生命周期和应用的一样长，这就导致了该静态实例一直会持有该Activity的引用，导致Activity的内存资源不能正常回收。正确的做法为： 将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，请按照上面推荐的使用Application 的 Context。当然，Application 的 context 不是万能的，所以也不能随便乱用，对于有些地方则必须使用 Activity 的 Context，对于Application，Service，Activity三者的Context的应用场景如下： 其中： NO1表示 Application 和 Service 可以启动一个 Activity，不过需要创建一个新的 task 任务队列。而对于 Dialog 而言，只有在 Activity 中才能创建 匿名内部类 android开发经常会继承实现Activity/Fragment/View，此时如果你使用了匿名类，并被异步线程持有了，那要小心了，如果没有任何措施这样一定会导致泄露 ``` public class MainActivity extends Activity { ... Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() { @Override public void run() { } }; ... } ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存： [![img](http://img2.tbcdn.cn/L1/461/1/fb05ff6d2e68f309b94dd84352c81acfe0ae839e)](javascript:;) 可以看到，ref1没什么特别的。 但ref2这个匿名类的实现对象里面多了一个引用： this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。 - Handler 造成的内存泄漏 Handler 的使用造成的内存泄漏问题应该说是最为常见了，很多时候我们为了避免 ANR 而不在主线程进行耗时操作，在处理网络任务或者封装一些请求回调等api都借助Handler来处理，但 Handler 不是万能的，对于 Handler 的使用代码编写一不规范即有可能造成内存泄漏。另外，我们知道 Handler、Message 和 MessageQueue 都是相互关联在一起的，万一 Handler 发送的 Message 尚未被处理，则该 Message 及发送它的 Handler 对象将被线程 MessageQueue 一直持有。 由于 Handler 属于 TLS(Thread Local Storage) 变量, 生命周期和 Activity 是不一致的。因此这种实现方式一般很难保证跟 View 或者 Activity 的生命周期保持一致，故很容易导致无法正确释放。 举个例子： public class SampleActivity extends Activity { private final Handler mLeakyHandler = new Handler() { @Override public void handleMessage(Message msg) { // ... } } @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mLeakyHandler.postDelayed(new Runnable() { @Override public void run() { / ... / } }, 1000 60 10); // Go back to the previous Activity. finish(); } } 在该 SampleActivity 中声明了一个延迟10分钟执行的消息 Message，mLeakyHandler 将其 push 进了消息队列 MessageQueue 里。当该 Activity 被 finish() 掉时，延迟执行任务的 Message 还会继续存在于主线程中，它持有该 Activity 的 Handler 引用，所以此时 finish() 掉的 Activity 就不会被回收了从而造成内存泄漏（因 Handler 为非静态内部类，它会持有外部类的引用，在这里就是指 SampleActivity）。 修复方法：在 Activity 中避免使用非静态内部类，比如上面我们将 Handler 声明为静态的，则其存活期跟 Activity 的生命周期就无关了。同时通过弱引用的方式引入 Activity，避免直接将 Activity 作为 context 传进去，见下面代码： public class SampleActivity extends Activity { /** Instances of static inner classes do not hold an implicit reference to their outer class. */ private static class MyHandler extends Handler { private final WeakReference mActivity; public MyHandler(SampleActivity activity) { mActivity = new WeakReference(activity); } @Override public void handleMessage(Message msg) { SampleActivity activity = mActivity.get(); if (activity != null) { // ... } } } private final MyHandler mHandler = new MyHandler(this); /** Instances of anonymous classes do not hold an implicit reference to their outer class when they are \"static\". */ private static final Runnable sRunnable = new Runnable() { @Override public void run() { / ... / } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // Post a message and delay its execution for 10 minutes. mHandler.postDelayed(sRunnable, 1000 60 10); // Go back to the previous Activity. finish(); } } 综述，即推荐使用静态内部类 + WeakReference 这种方式。每次使用前注意判空。 前面提到了 WeakReference，所以这里就简单的说一下 Java 对象的几种引用类型。 Java对引用的分类有 Strong reference, SoftReference, WeakReference, PhatomReference 四种。 [![img](https://gw.alicdn.com/tps/TB1U6TNLVXXXXchXFXXXXXXXXXX-644-546.jpg)](javascript:;) 在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。 软/弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。利用这个队列可以得知被回收的软/弱引用的对象列表，从而为缓冲器清除已失效的软/弱引用。 假设我们的应用会用到大量的默认图片，比如应用中有默认的头像，默认游戏图标等等，这些图片很多地方会用到。如果每次都去读取图片，由于读取文件需要硬件操作，速度较慢，会导致性能较低。所以我们考虑将图片缓存起来，需要的时候直接从内存中读取。但是，由于图片占用内存空间比较大，缓存很多图片需要很多的内存，就可能比较容易发生OutOfMemory异常。这时，我们可以考虑使用软/弱引用技术来避免这个问题发生。以下就是高速缓冲器的雏形： 首先定义一个HashMap，保存软引用对象。 private Map > imageCache = new HashMap > (); 再来定义一个方法，保存Bitmap的软引用到HashMap。 [![img](https://gw.alicdn.com/tps/TB1oW_FLVXXXXXuaXXXXXXXXXXX-679-717.jpg)](javascript:;) 使用软引用以后，在OutOfMemory异常发生之前，这些缓存的图片资源的内存空间可以被释放掉的，从而避免内存达到上限，避免Crash发生。 如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。 另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。 ok，继续回到主题。前面所说的，创建一个静态Handler内部类，然后对 Handler 持有的对象使用弱引用，这样在回收时也可以回收 Handler 持有的对象，但是这样做虽然避免了 Activity 泄漏，不过 Looper 线程的消息队列中还是可能会有待处理的消息，所以我们在 Activity 的 Destroy 时或者 Stop 时应该移除消息队列 MessageQueue 中的消息。 下面几个方法都可以移除 Message： public final void removeCallbacks(Runnable r); public final void removeCallbacks(Runnable r, Object token); public final void removeCallbacksAndMessages(Object token); public final void removeMessages(int what); public final void removeMessages(int what, Object object); - 尽量避免使用 static 成员变量 如果成员变量被声明为 static，那我们都知道其生命周期将与整个app进程生命周期一样。 这会导致一系列问题，如果你的app进程设计上是长驻内存的，那即使app切到后台，这部分内存也不会被释放。按照现在手机app内存管理机制，占内存较大的后台进程将优先回收，yi'wei如果此app做过进程互保保活，那会造成app在后台频繁重启。当手机安装了你参与开发的app以后一夜时间手机被消耗空了电量、流量，你的app不得不被用户卸载或者静默。 这里修复的方法是： 不要在类初始时初始化静态成员。可以考虑lazy初始化。 架构设计上要思考是否真的有必要这样做，尽量避免。如果架构需要这么设计，那么此对象的生命周期你有责任管理起来。 - 避免 override finalize() 1、finalize 方法被执行的时间不确定，不能依赖与它来释放紧缺的资源。时间不确定的原因是： - 虚拟机调用GC的时间不确定 - Finalize daemon线程被调度到的时间不确定 2、finalize 方法只会被执行一次，即使对象被复活，如果已经执行过了 finalize 方法，再次被 GC 时也不会再执行了，原因是： 含有 finalize 方法的 object 是在 new 的时候由虚拟机生成了一个 finalize reference 在来引用到该Object的，而在 finalize 方法执行的时候，该 object 所对应的 finalize Reference 会被释放掉，即使在这个时候把该 object 复活(即用强引用引用住该 object )，再第二次被 GC 的时候由于没有了 finalize reference 与之对应，所以 finalize 方法不会再执行。 3、含有Finalize方法的object需要至少经过两轮GC才有可能被释放。 详情见这里 [深入分析过dalvik的代码](http://blog.csdn.net/kai_gong/article/details/24188803) - 资源未关闭造成的内存泄漏 对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销，否则这些资源将不会被回收，造成内存泄漏。 - 一些不良代码造成的内存压力 有些代码并不造成内存泄露，但是它们，或是对没使用的内存没进行有效及时的释放，或是没有有效的利用已有的对象而是频繁的申请新内存。 比如： - Bitmap 没调用 recycle()方法，对于 Bitmap 对象在不使用时,我们应该先调用 recycle() 释放内存，然后才它设置为 null. 因为加载 Bitmap 对象的内存空间，一部分是 java 的，一部分 C 的（因为 Bitmap 分配的底层是通过 JNI 调用的 )。 而这个 recyle() 就是针对 C 部分的内存释放。 - 构造 Adapter 时，没有使用缓存的 convertView ,每次都在创建新的 converView。这里推荐使用 ViewHolder。 ### 工具分析 Java 内存泄漏的分析工具有很多，但众所周知的要数 MAT(Memory Analysis Tools) 和 YourKit 了。由于篇幅问题，我这里就只对 [MAT](http://www.eclipse.org/mat/) 的使用做一下介绍。--> [MAT 的安装](http://www.ibm.com/developerworks/cn/opensource/os-cn-ecl-ma/index.html) - MAT分析heap的总内存占用大小来初步判断是否存在泄露 打开 DDMS 工具，在左边 Devices 视图页面选中“Update Heap”图标，然后在右边切换到 Heap 视图，点击 Heap 视图中的“Cause GC”按钮，到此为止需检测的进程就可以被监视。 [![img](https://gw.alicdn.com/tps/TB1pdf2LVXXXXXeXXXXXXXXXXXX-690-514.jpg)](javascript:;) Heap视图中部有一个Type叫做data object，即数据对象，也就是我们的程序中大量存在的类类型的对象。在data object一行中有一列是“Total Size”，其值就是当前进程中所有Java数据对象的内存总量，一般情况下，这个值的大小决定了是否会有内存泄漏。可以这样判断： 进入某应用，不断的操作该应用，同时注意观察data object的Total Size值，正常情况下Total Size值都会稳定在一个有限的范围内，也就是说由于程序中的的代码良好，没有造成对象不被垃圾回收的情况。 所以说虽然我们不断的操作会不断的生成很多对象，而在虚拟机不断的进行GC的过程中，这些对象都被回收了，内存占用量会会落到一个稳定的水平；反之如果代码中存在没有释放对象引用的情况，则data object的Total Size值在每次GC后不会有明显的回落。随着操作次数的增多Total Size的值会越来越大，直到到达一个上限后导致进程被杀掉。 - MAT分析hprof来定位内存泄露的原因所在 这是出现内存泄露后使用MAT进行问题定位的有效手段。 A)Dump出内存泄露当时的内存镜像hprof，分析怀疑泄露的类： [![img](https://gw.alicdn.com/tps/TB1r2zZLVXXXXcHXXXXXXXXXXXX-640-167.jpg)](javascript:;) B)分析持有此类对象引用的外部对象 [![img](https://gw.alicdn.com/tps/TB17XvOLVXXXXbiXFXXXXXXXXXX-640-90.png)](javascript:;) C)分析这些持有引用的对象的GC路径 [![img](https://gw.alicdn.com/tps/TB10yTwLVXXXXaRapXXXXXXXXXX-640-278.png)](javascript:;) D)逐个分析每个对象的GC路径是否正常 [![img](https://gw.alicdn.com/tps/TB1CWTQLVXXXXamXFXXXXXXXXXX-640-90.png)](javascript:;) 从这个路径可以看出是一个antiRadiationUtil工具类对象持有了MainActivity的引用导致MainActivity无法释放。此时就要进入代码分析此时antiRadiationUtil的引用持有是否合理（如果antiRadiationUtil持有了MainActivity的context导致节目退出后MainActivity无法销毁，那一般都属于内存泄露了）。 - MAT对比操作前后的hprof来定位内存泄露的根因所在 为查找内存泄漏，通常需要两个 Dump结果作对比，打开 Navigator History面板，将两个表的 Histogram结果都添加到 Compare Basket中去 A） 第一个HPROF 文件(usingFile > Open Heap Dump ). B）打开Histogram view. C）在NavigationHistory view里 (如果看不到就从Window >show view>MAT- Navigation History ), 右击histogram然后选择Add to Compare Basket . [![img](https://gw.alicdn.com/tps/TB1p1rULVXXXXbyXpXXXXXXXXXX-525-212.png)](javascript:;) D）打开第二个HPROF 文件然后重做步骤2和3. E）切换到Compare Basket view, 然后点击Compare the Results (视图右上角的红色”!”图标)。 [![img](https://gw.alicdn.com/tps/TB1p0zKLVXXXXX.XVXXXXXXXXXX-640-98.png)](javascript:;) F）分析对比结果 [![img](https://gw.alicdn.com/tps/TB1lwDMLVXXXXcUXFXXXXXXXXXX-640-115.png)](javascript:;) 可以看出两个hprof的数据对象对比结果。 通过这种方式可以快速定位到操作前后所持有的对象增量，从而进一步定位出当前操作导致内存泄露的具体原因是泄露了什么数据对象。 注意： 如果是用 MAT Eclipse 插件获取的 Dump文件，不需要经过转换则可在MAT中打开，Adt会自动进行转换。 而手机SDk Dump 出的文件要经过转换才能被 MAT识别，Android SDK提供了这个工具 hprof-conv (位于 sdk/tools下) 首先，要通过控制台进入到你的 android sdk tools 目录下执行以下命令： ./hprof-conv xxx-a.hprof xxx-b.hprof 例如 hprof-conv input.hprof out.hprof 此时才能将out.hprof放在eclipse的MAT中打开。 Ok，下面将给大家介绍一个屌炸天的工具 -- LeakCanary 。 ### 使用 LeakCanary 检测 Android 的内存泄漏 什么是 [LeakCanary](https://github.com/square/leakcanary) 呢？为什么选择它来检测 Android 的内存泄漏呢？ 别急，让我来慢慢告诉大家！ LeakCanary 是国外一位大神 Pierre-Yves Ricau 开发的一个用于检测内存泄露的开源类库。一般情况下，在对战内存泄露中，我们都会经过以下几个关键步骤： 1、了解 OutOfMemoryError 情况。 2、重现问题。 3、在发生内存泄露的时候，把内存 Dump 出来。 4、在发生内存泄露的时候，把内存 Dump 出来。 5、计算这个对象到 GC roots 的最短强引用路径。 6、确定引用路径中的哪个引用是不该有的，然后修复问题。 很复杂对吧？ 如果有一个类库能在发生 OOM 之前把这些事情全部都搞定，然后你只要修复这些问题就好了。LeakCanary 做的就是这件事情。你可以在 debug 包中轻松检测内存泄露。 一起来看这个例子（摘自 LeakCanary 中文使用说明，下面会附上所有的参考文档链接）： class Cat { } class Box { Cat hiddenCat; } class Docker { // 静态变量，将不会被回收，除非加载 Docker 类的 ClassLoader 被回收。 static Box container; } // ... Box box = new Box(); // 薛定谔之猫 Cat schrodingerCat = new Cat(); box.hiddenCat = schrodingerCat; Docker.container = box; 创建一个RefWatcher，监控对象引用情况。 // 我们期待薛定谔之猫很快就会消失（或者不消失），我们监控一下 refWatcher.watch(schrodingerCat); 当发现有内存泄露的时候，你会看到一个很漂亮的 leak trace 报告: - GC ROOT static Docker.container - references Box.hiddenCat - leaks Cat instance 我们知道，你很忙，每天都有一大堆需求。所以我们把这个事情弄得很简单，你只需要添加一行代码就行了。然后 LeakCanary 就会自动侦测 activity 的内存泄露了。 public class ExampleApplication extends Application { @Override public void onCreate() { super.onCreate(); LeakCanary.install(this); } } 然后你会在通知栏看到这样很漂亮的一个界面: [![img](https://corner.squareup.com/images/leakcanary/leaktrace.png)](javascript:;) 以很直白的方式将内存泄露展现在我们的面前。 #### Demo 一个非常简单的 LeakCanary demo: [一个非常简单的 LeakCanary demo: https://github.com/liaohuqiu/leakcanary-demo](https://github.com/liaohuqiu/leakcanary-demo) #### 接入 在 build.gradle 中加入引用，不同的编译使用不同的引用： dependencies { debugCompile 'com.squareup.leakcanary:leakcanary-android:1.3' releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.3' } #### 如何使用 使用 RefWatcher 监控那些本该被回收的对象。 RefWatcher refWatcher = {...}; // 监控 refWatcher.watch(schrodingerCat); LeakCanary.install() 会返回一个预定义的 RefWatcher，同时也会启用一个 ActivityRefWatcher，用于自动监控调用 Activity.onDestroy() 之后泄露的 activity。 在Application中进行配置 ： public class ExampleApplication extends Application { public static RefWatcher getRefWatcher(Context context) { ExampleApplication application = (ExampleApplication) context.getApplicationContext(); return application.refWatcher; } private RefWatcher refWatcher; @Override public void onCreate() { super.onCreate(); refWatcher = LeakCanary.install(this); } } 使用 RefWatcher 监控 Fragment： public abstract class BaseFragment extends Fragment { @Override public void onDestroy() { super.onDestroy(); RefWatcher refWatcher = ExampleApplication.getRefWatcher(getActivity()); refWatcher.watch(this); } } 使用 RefWatcher 监控 Activity： public class MainActivity extends AppCompatActivity { ...... @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //在自己的应用初始Activity中加入如下两行代码 RefWatcher refWatcher = ExampleApplication.getRefWatcher(this); refWatcher.watch(this); textView = (TextView) findViewById(R.id.tv); textView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { startAsyncTask(); } }); } private void async() { startAsyncTask(); } private void startAsyncTask() { // This async task is an anonymous class and therefore has a hidden reference to the outer // class MainActivity. If the activity gets destroyed before the task finishes (e.g. rotation), // the activity instance will leak. new AsyncTask() { @Override protected Void doInBackground(Void... params) { // Do some slow work in background SystemClock.sleep(20000); return null; } }.execute(); } } ``` 工作机制 1.RefWatcher.watch() 创建一个 KeyedWeakReference 到要被监控的对象。 2.然后在后台线程检查引用是否被清除，如果没有，调用GC。 3.如果引用还是未被清除，把 heap 内存 dump 到 APP 对应的文件系统中的一个 .hprof 文件中。 4.在另外一个进程中的 HeapAnalyzerService 有一个 HeapAnalyzer 使用HAHA 解析这个文件。 5.得益于唯一的 reference key, HeapAnalyzer 找到 KeyedWeakReference，定位内存泄露。 6.HeapAnalyzer 计算 到 GC roots 的最短强引用路径，并确定是否是泄露。如果是的话，建立导致泄露的引用链。 7.引用链传递到 APP 进程中的 DisplayLeakService， 并以通知的形式展示出来。 ok,这里就不再深入了，想要了解更多就到 作者 github 主页 这去哈。 总结 对 Activity 等组件的引用应该控制在 Activity 的生命周期之内； 如果不能就考虑使用 getApplicationContext 或者 getApplication，以避免 Activity 被外部长生命周期的对象引用而泄露。 尽量不要在静态变量或者静态内部类中使用非静态外部成员变量（包括context )，即使要使用，也要考虑适时把外部成员变量置空；也可以在内部类中使用弱引用来引用外部类的变量。 对于生命周期比Activity长的内部类对象，并且内部类中使用了外部类的成员变量，可以这样做避免内存泄漏： 将内部类改为静态内部类 静态内部类中使用弱引用来引用外部类的成员变量 Handler 的持有的引用对象最好使用弱引用，资源释放时也可以清空 Handler 里面的消息。比如在 Activity onStop 或者 onDestroy 的时候，取消掉该 Handler 对象的 Message和 Runnable. 在 Java 的实现过程中，也要考虑其对象释放，最好的方法是在不使用某对象时，显式地将此对象赋值为 null，比如使用完Bitmap 后先调用 recycle()，再赋为null,清空对图片等资源有直接引用或者间接引用的数组（使用 array.clear() ; array = null）等，最好遵循谁创建谁释放的原则。 正确关闭资源，对于使用了BraodcastReceiver，ContentObserver，File，游标 Cursor，Stream，Bitmap等资源的使用，应该在Activity销毁时及时关闭或者注销。 保持对对象生命周期的敏感，特别注意单例、静态对象、全局性集合等的生命周期。 以上部分图片、实例代码和文段都摘自或参考以下文章 ： IBM ： Java的内存泄漏 Android Design Patterns ： How to Leak a Context: Handlers & Inner Classes 伯乐在线团队： Android性能优化之常见的内存泄漏 我厂同学 ： Dalvik虚拟机 Finalize 方法执行分析 腾讯bugly ： 内存泄露从入门到精通三部曲之基础知识篇 内存泄露从入门到精通三部曲之排查方法篇 内存泄露从入门到精通三部曲之常见原因与用户实践 LeakCanary : LeakCanary 中文使用说明 LeakCanary: 让内存泄露无所遁形 https://github.com/square/leakcanary Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/Android 项目搭建的一些配置.html":{"url":"Android/Android知识点/Android 项目搭建的一些配置.html","title":"Android 项目搭建的一些配置","keywords":"","body":"加入分包的配置，防止method的个数查过65k /*加入分包配置*/ defaultConfig { ... multiDexEnabled true ... } dependencies { /* multiDex */ compile 'com.android.support:multidex:1.0.1' } 如果你的工程中已经含有Application类,那么让它继承android.support.multidex.MultiDexApplication类 如果你的Application已经继承了其他类并且不想做改动，那么还有另外一种使用方式,覆写attachBaseContext()方法: public class MyApplication extends FooApplication { @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); MultiDex.install(this); } } OutOfMemoryError: Java heap space 当运行时如果看到如下错误: UNEXPECTED TOP-LEVEL ERROR: java.lang.OutOfMemoryError: Java heap space 在dexOptions中有一个字段用来增加java堆内存大小: android { // ... dexOptions { javaMaxHeapSize \"2g\" } } 错误Conflict with dependency 'com.google.code.findbugs:jsr305' 解决方法 Android{ configurations.all { resolutionStrategy.force 'com.google.code.findbugs:jsr305:1.3.9' } } Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/Android Handler 避免内存泄露.html":{"url":"Android/Android知识点/Android Handler 避免内存泄露.html","title":"Android Handler 避免内存泄露","keywords":"","body":"Android App 内存泄露之Handler Handler也是造成内存泄露的一个重要的源头，主要Handler属于TLS(Thread Local Storage)变量,生命周期和Activity是不一致的，Handler引用Activity会存在内存泄露。看一下如下代码 ``` /** 实现的主要功能。 @version 1.0.0 @author Abay Zhuang Create at 2014-7-28 */ public class HandlerActivity extends Activity { private final Handler mHandler = new Handler() { @Override public void handleMessage(Message msg) { // ... } }; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 60000); //just finish this activity finish(); } } 是否您以前也是这样用的呢。 没有问题？ ![](https://ws3.sinaimg.cn/large/006tKfTcly1fjhrpydf59j30zj0c1q5h.jpg) This Handler class should be static or leaks might occur (com.example.ta.HandlerActivity.1) 意思：class 使用静态声明否者可能出现内存泄露。 为啥出现这样的问题呢 > Handler 的生命周期与Activity 不一致 当Android应用启动的时候，会先创建一个UI主线程的Looper对象，Looper实现了一个简单的消息队列，一个一个的处理里面的Message对象。主线程Looper对象在整个应用生命周期中存在。 当在主线程中初始化Handler时，该Handler和Looper的消息队列关联（没有关联会报错的）。发送到消息队列的Message会引用发送该消息的Handler对象，这样系统可以调用 Handler#handleMessage(Message) 来分发处理该消息。 handler 引用 Activity 阻止了GC对Acivity的回收 在Java中，非静态(匿名)内部类会默认隐性引用外部类对象。而静态内部类不会引用外部类对象。 如果外部类是Activity，则会引起Activity泄露 。 当Activity finish后，延时消息会继续存在主线程消息队列中1分钟，然后处理消息。而该消息引用了Activity的Handler对象，然后这个Handler又引用了这个Activity。这些引用对象会保持到该消息被处理完，这样就导致该Activity对象无法被回收，从而导致了上面说的 Activity泄露。 > 如何避免修？ 使用显形的引用，1.静态内部类。 2. 外部类 使用弱引用 2. WeakReference 修改代码如下： /** 实现的主要功能。 @version 1.0.0 @author Abay Zhuang Create at 2014-7-28 */ public class HandlerActivity2 extends Activity { private static final int MESSAGE_1 = 1; private static final int MESSAGE_2 = 2; private static final int MESSAGE_3 = 3; private final Handler mHandler = new MyHandler(this); @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mHandler.sendMessageDelayed(Message.obtain(), 60000); // just finish this activity finish(); } public void todo() { }; private static class MyHandler extends Handler { private final WeakReference mActivity; public MyHandler(HandlerActivity2 activity) { mActivity = new WeakReference(activity); } @Override public void handleMessage(Message msg) { System.out.println(msg); if (mActivity.get() == null) { return; } mActivity.get().todo(); } } ``` 上面这样就可以了吗？ 当Activity finish后 handler对象还是在Message中排队。 还是会处理消息，这些处理有必要？ 正常Activitiy finish后，已经没有必要对消息处理，那需要怎么做呢？ 解决方案也很简单，在Activity onStop或者onDestroy的时候，取消掉该Handler对象的Message和Runnable。 通过查看Handler的API，它有几个方法：removeCallbacks(Runnable r)和removeMessages(int what)等。 代码如下： /** * 一切都是为了不要让mHandler拖泥带水 */ @Override public void onDestroy() { mHandler.removeMessages(MESSAGE_1); mHandler.removeMessages(MESSAGE_2); mHandler.removeMessages(MESSAGE_3); // ... ... mHandler.removeCallbacks(mRunnable); // ... ... } 如果上面觉的麻烦，也可以如下面： @Override public void onDestroy() { // If null, all callbacks and messages will be removed. mHandler.removeCallbacksAndMessages(null); } Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/Android知识点/Android Tools 属性介绍.html":{"url":"Android/Android知识点/Android Tools 属性介绍.html","title":"Android Tools 属性介绍","keywords":"","body":"xml 布局文件在 Android 开发中是必不可以少的一部分，开发者对里面 android 前缀的属性非常熟悉，android:layout_width， android:layout_height，android:orientation 。这里要介绍的是另外一种一个非常实用且容易被忽略的 tools 属性。 新创建 xml 布局文件的时候，你可能会发现在布局根元素里默认添加了 tools 相关的属性 xmlns:tools ，tools:context 如果删掉 tools 相关的属性的时候，并不会引起编译问题跟布局预览问题，也不会影响代码的执行。那么这个属性到底有什么用？好，先挖个坑，下面再填坑。 tools 相关的属性大致分为三类： 解决指定的 Lint 的警告提示 强化 xml 布局预览属性 资源缩减属性。 解决指定的 Lint 的警告提示 解决lint警告提示的 tools 属性有 tools:ignore，tools:targetApi，tools:locale，分别用于忽略指定的 lint 异常警告提示，申明控件的运行系统版本，申明资源文件的语言条件。 tools:ignore 用于忽略指定的 lint 异常警告提示。我们经常会用 Android studio 里面的功能 Analyze -> Inspect Code 检查项目中可能存在的问题,但是有些警告只是官方规范建议，并不是真的存在潜在bug，如果要解决这类问题可以使用tools:ignore 来忽略一些异常警告提示。 比如经常出现的 Image without contentDescription 异常警告 这是因为 ImageView 属性少加了 android:contentDescription 但是实际开发中一般很少去添加这个属性。在布局的根元素添加 xmlns:tools=\"http://schemas.android.com/tools\" tools:ignore=\"ContentDescription\"，便可以忽略这个警告提示 如果有多个指定异常需要进行忽略的情况，只需要在用逗号分割即可。例如tools:ignore=\"ContentDescription,UselessParent\"。关于lint 警告的类型可通过文档查找相关对应类型http://tools.android.com/tips/lint-checks tools:targetApi 用于忽略控件高版本引发的 lint 异常警告提示。如果你在布局中使用高于项目的最低版本的属性或者控件， lint 就发出警告。比如，在最低版本是14的项目中使用了26版本才的新增的android:layout_marginHorizontal 如果我们已经确认这个布局肯定是26版本中使用的，不会低版本中使用的时候，我们就使用可以tools:targetApi=\"26\" 去消除这个警告。 tools:locale 用于声明资源文件的运行语言环境。很多时候都会出现一些拼写异常的警告，虽然这些警告可以说不痛不痒，如果要解决这个问题，只要我们把这个资源的运行设置成非英文类型即可。更多使用于资源文件的根元素。比如： 这段代码意思就是将该资源文件的语言运行环境设置成西班牙而不是默认英文。 强化 xml 布局预览属性 tools 显示 android 属性 用于预览界面显示而不影响实际代码显示。在实际开发中，我们编写界面的时候，为了预览界面显示效果，我们会使用一些测试数据来填充。但是这会引发一个问题，就是你设置这些测试数据后，没有将这些测试数据的值清理，又在运行中没有业务数据去填充这些值，在实际运行界面中就会显示这些测试数据。就算我们及时清理那些测试数据，这个界面就显得白茫茫一篇，如果布局比较复杂嵌套比较深，你甚至很难定位到你想要的控件。这时候我们就可以用 tools 前缀去显示 android 前缀的属性。 看代码： 在以上代码中，我们在 TextView 控件 background,text ,ImageView控件的src，CheckBox控件的checked 都加上了tools的前缀。在预览界面中显示情况是： 跟我们用 android 前缀使用情况是一样的，但是这些属性的值在运行的时候并不会出现。当然，tools 可以显示的属性并不止这几个，它能显示所有以 android 前缀开头的属性。 tools:context 使该布局预览的主题与指定的 activity 主题一致（这就是我们在文章最开始的挖的坑，现在填坑）。在布局的根元素添加tools:context=\".activity名字\" 即可。 tools:layout 使该布局的 fragment 填充布局预览。因为 fragment 只能在 Java 代码中填充布局，如果不编译运行是无法看到 fragment 布局情况，这个属性就可以帮助 fragment 显示需要填充的界面。注意的是，这个布局并不会真正带入到编译中去，只是帮助显示预览而已。 看下代码： 这时候 IDE 右边的预览界面即可显示 fragment 的布局 tools:listitem / tools:listheader / tools:listfooter 使该布局的 ListView 填充 item ，header，footer 布局预览。这个属性的作用跟 tools:layout 作用的是类似的，只是这个属性只作用于 ListView。 (tools:listitem 也可以作用于RecycleView)。 PS : 需要给ListView /RecycleView 添加上 id 不然预览布局无法生效。 tools:showIn 使 include 布局预览显示嵌套布局的界面。在include 的布局上添加 tools:showIn=\"@layout/嵌套布局名字\"，即可显示嵌套布局的预览情况。 在预览界面显示的是嵌套布局整体界面 资源缩减属性 tools:shrinkMode 开启严格引用检查。我们在 res/raw/keep.xml 文件里面，设置是否启用严格引用检查。 shrinkMode 有两种模式，一种是 safe，一种是strict，默认情况是safe。 shrinkMode 是 safe 的情况下： 当我们开启shrinkResources true的时候，gradle 的资源缩减器就会清除无用资源文件，如果是间接引用的资源则不清理，比如 Resources.getIdentifier()。 shrinkMode 是 strict的情况下： 当我们开启shrinkResources true的时候，gradle 的资源缩减器就会清除无用资源文件，但是间接引用的资源则不清理，比如 Resources.getIdentifier()。 如果我们需要开启 strict 默认的情况，需要保留简洁引用的资源文件的话，则需要在 keep.xml 保留指定资源文件。下面会详解。 tools:keep 指定保留资源。在 gradle 开启了 shrinkResources true，并且 shrinkMode 是 strict 模式情况，如果一些资源文件不是直接引用的，而是间接引用的也会收到清理，比如我们用 Resources.getIdentifier() 动态去获取指定资源 ID。如果想要这些文件不受 lint 资源清理的影响，可以在keep.xml 文件，指定保留无需清理的 xml 文件。 多个文件只需要用逗号分隔，并且支持星号作为通配符。 tools:discard 指定资源缩减。这个功能跟tools:keep 刚好是相反的，我们可以指定某些资源可以被清理掉。通常是用于资源文件在代码中已经被引用，但实际清理掉也不影响代码执行的情况，或者 gradle 插件判断错误情况下。可能你会认为这个功能看起来很鸡肋，好像还不如删掉直截了当，但是在某些场景下却非常有用，比如构建多个 Variant 的时候。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-14 13:56:52 var className='atoc';"},"Android/Android知识点/APP 启动优化.html":{"url":"Android/Android知识点/APP 启动优化.html","title":"APP 启动优化","keywords":"","body":"解决方案 在 Android 开发中,应用启动速度是一个非常重要的点，应用启动优化也是一个非常重要的过程。对于应用启动优化，其实核心思想就是在启动过程中少做事情，具体实践的时候无非就是下面几种： 异步加载 延时加载 懒加载 不用一一去解释,做过启动优化的估计都使用过，本篇文章将详细讲解一下一种延时加载的实现以及其原理. 其实这种加载的实现是非常简单的,但是其中的原理可能比较复杂，还涉及到Looper/Handler/MessageQueue/VSYNC等。以及其中碰到的一些问题，还会有一些我自己额外的思考。 优化后的DelayLoad的实现 一提到DelayLoad,大家可能第一时间想到的就是在 onCreate里面调用Handler.postDelayed方法, 将需要 Delay 加载的东西放到这里面去初始化, 这个也是一个比较方便的方法. Delay一段时间再去执行,这时候应用已经加载完成,界面已经显示出来了, 不过这个方法有一个致命的问题: 延迟多久? 大家都知道,在 Android 的高端机型上,应用的启动是非常快的 , 这时候只需要 Delay 很短的时间就可以了, 但是在低端机型上,应用的启动就没有那么快了,而且现在应用为了兼容旧的机型,往往需要 Delay 较长的时间,这样带来体验上的差异是很明显的. 这里先说优化方案: 首先 , 创建 Handler 和 Runnable 对象, 其中 Runnable 对象的 run方法里面去更新 UI 线程. private Handler myHandler = new Handler(); private Runnable mLoadingRunnable = new Runnable() { @Override public void run() { updateText(); //更新UI线程 } }; 在主 Activity 的 onCreate 中加入下面的代码 getWindow().getDecorView().post(new Runnable() { @Override public void run() { myHandler.post(mLoadingRunnable); } }); 其实实现的话非常简单,我们来对比一下三种方案的效果. 2. 三种写法的差异对比 为了验证我们优化的 DelayLoad的效果,我们写了一个简单的app , 这个 App 中包含三张不同大小的图片,每张图片下面都会有一个 TextView , 来标记图片的显示高度和宽度. MainActivity的代码如下: public class MainActivity extends AppCompatActivity { private static final int DEALY_TIME = 300 ; private ImageView imageView1; private ImageView imageView2; private ImageView imageView3; private TextView textView1; private TextView textView2; private TextView textView3; private Handler myHandler = new Handler(); private Runnable mLoadingRunnable = new Runnable() { @Override public void run() { updateText(); } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); imageView1 = (ImageView) findViewById(R.id.image1); imageView2 = (ImageView) findViewById(R.id.image2); imageView3 = (ImageView) findViewById(R.id.image3); textView1 = (TextView) findViewById(R.id.text1); textView2 = (TextView) findViewById(R.id.text2); textView3 = (TextView) findViewById(R.id.text3); // 第一种写法:直接Post myHandler.post(mLoadingRunnable); // 第二种写法:直接PostDelay 300ms. // myHandler.postDelayed(mLoadingRunnable, DEALY_TIME); // 第三种写法:优化的DelayLoad // getWindow().getDecorView().post(new Runnable() { // @Override // public void run() { // myHandler.post(mLoadingRunnable); // } // }); // Dump当前的MessageQueue信息. getMainLooper().dump(new Printer() { @Override public void println(String x) { Log.i(\"Gracker\",x); } },\"onCreate\"); } private void updateText() { TraceCompat.beginSection(\"updateText\"); textView1.setText(\"image1 : w=\" + imageView1.getWidth() + \" h =\" + imageView1.getHeight()); textView2.setText(\"image2 : w=\" + imageView2.getWidth() + \" h =\" + imageView2.getHeight()); textView3.setText(\"image3 : w=\" + imageView3.getWidth() + \" h =\" + imageView3.getHeight()); TraceCompat.endSection(); } 我们需要关注两个点: updateText 这个函数是什么时候被执行的? App 启动后,三个图片的长宽是否可以被正确地显示出来? 是否有 Delay Load 的效果? 2.1 第一种写法 updateText执行的时机? 下面是第一种写法的Trace图: 第一种写法 可以看到 updateText 是在 Activity 的 w/onStart/onResume三个回调执行完成后才去执行的. 图片的宽高是否正确显示? 第一种写法 从图片看一看到,宽高并没有显示. 这是为什么呢? 这个问题就要从Activity 的 onCreate/onStart/onResume三个回调说起了. 其实Activity 的 onCreate/onStart/onResume三个回调中,并没有执行Measure和Layout操作, 这个是在后面的performTraversals中才执行的. 所以在这之前宽高都是0. 是否有 Delay Load 的效果? 并没有. 因为我们知道, 应用启动的时候,要等两次 performTraversals 都执行完成之后才会显示第一帧, 而 updateText这个方法在第一个 performTraversals 执行之前就执行了. 所以updateText方法的执行时间是算在应用启动的时间里面的. 2.2 第二种写法 第二种写法我们Delay了300ms .我们来看一下表现. updateText执行的时机? 第二种写法 可以看到,这种写法的话,updateText是在两个performTraversals 执行完成之后(这时候 APP 的第一帧才显示出来)才去执行的, 执行完成之后又调用了一次 performTraversals 将 TextView 的内容进行更新. 图片的宽高是否正确显示? 第二种写法 从上图可以看到,图片的宽高是正确显示了出来. 原因上面已经说了,measure/layout执行完成后,宽高的数据就可以获取了. 是否有 Delay Load 的效果? 不一定,取决于 Delay的时长. 从前面的 Trace 图上我们可以看到 , updateText 方法由于 Delay 了300ms, 所以在应用第一帧显示出来170ms之后, 图片的文字信息才进行了更新. 这个是有 Delay Load 的效果的. 但是这里只是一个简单的TextView的更新, 如果是较大模块的加载 , 用户视觉上会有很明显的 “ 空白->内容填充” 这个过程, 或者会附加”闪一下”特效…这显然是我们不想看到的. 有人会说:可以把Delay的时间减小一点嘛,这样就不会闪了. 话是这么说,但是由于 Android 机器的多元性(其实就是有很多高端机器,也有很多低端机器) , 在这个机子上300ms的延迟算是快,在另外一个机子上300ms算是很慢. 我们将Delay时间调整为50ms, 其Trace图如下: 第二种写法:Delay 50ms 可以看到,updateText 方法在第一个 performTraversals 之后就执行了,所以也没有 Delay Load 的效果(虽然宽高是正确显示了,因为在第一个 performTraversals 方法中就执行了layout和measure). 2.3 第三种写法 经过前两个方法 , 我们就会想, 如果能不使用Delay方法, updateText 方法能在 第二个performTraversals 方法执行完成后(即APP第一帧在屏幕上显示),马上就去执行,那么即起到了 Delay Load的作用,又可以正确显示图片的宽高. 第三种写法就是这个效果: updateText执行的时机? 第三种写法 可以看到这种写法. updateText 在第二个 performTraversals 方法执行完成后马上就执行了, 然后下一个 VSYNC 信号来了之后, TextView就更新了. 图片的宽高是否正确显示? 当然是正确显示的.如图: 第三种写法 是否有 Delay Load 的效果? 从 Trace 图上看, 是有 Delay Load的效果的, 而且可以在应用第一帧显示后马上进行数据 Load , 不用考虑 Delay时间的长短. 3. 一些思考 关于优化的 Delay Load 的实现,从代码层面来看其实是非常简单的.其带来的效果也是很赞的. 但是实现之后我们还需要思考一下,为何这么做就可以实现这种功能呢?很显然要回答这个问题,我们需要知道更底层的一些东西.这个还涉及到 Handler/Message/MessageQueue/Looper/VSYNC/ViewRootImpl等知识. 往大里说应该还涉及到AMS/WMS等.由于涉及到的东西比较多,我就不在这一篇里面阐述了, 下一篇文章将会从从原理上讲解一下为何优化的 Delay Load 会起作用. 原理 其中会涉及到一些 Android 中的比较重要的类，以及 Activity 生命周期中比较重要的几个函数。 其实这个其中的原理比较简单，不过要弄清楚其实现的过程，还是一件蛮好玩的事情，其中会用到一些工具，自己加调试代码等，一步一步下来，自己对 Activity 的启动的理解又深了一层，希望大家读完之后也会对大家有一定的帮助。 上一篇中我们最终使用的 DelayLoad 的核心方法是在 Activity 的 onCreate 函数中加入下面的方法 ： getWindow().getDecorView().post(new Runnable() { @Override public void run() { myHandler.post(mLoadingRunnable); } }); 我们一一来看涉及到的类和方法 1. Activity.getWindow 及 PhoneWindow 的初始化时机 Activity 的 getWindow 方法获取到的是一个 PhoneWindow 对象： public Window getWindow() { return mWindow; } 这个 mWindow 就是一个 PhoneWindow 对象，其初始化的时机为这个 Activity attach 的时候： final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor) { attachBaseContext(context); mFragments.attachActivity(this, mContainer, null); mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); ........ // PolicyManager.makeNewWindow(this) 最终会调用 Policy 的 makeNewWindow 方法 public Window makeNewWindow(Context context) { return new PhoneWindow(context); } } 这里需要注意 Activity 的 attach 方法很早就会调用的，是要早于 Activity 的 onCreate 方法的。 总结： PhoneWindow 与 Activity 是一对一的关系，通过上面的初始化过程你应该更加清楚这个概念 Android 中对 PhoneWindow 的注释是 ：Android-specific Window ，可见其重要性 PhoneWindow 中有很多大家比较熟悉的方法，比如 setContentView / addContentView 等 ； 也有几个重要的内部类，比如：DecorView ; 2. PhoneWindow.getDecorView 及 DecorView 的初始化时机 上面我们说到 DecorView是 PhoneWindow 的一个内部类，其定义如下： private final class DecorView extends FrameLayout implements RootViewSurfaceTaker 那么 DecorView 是什么时候初始化的呢？DecorView 是在 Activity 的父类的 onCreate 方法中被初始化的，比如我例子中的 MainActivity 是继承自 android.support.v7.app.AppCompatActivity ，当我们调用 MainActivity 的 super.onCreate(savedInstanceState); 的时候，就会调用下面的 protected void onCreate(@Nullable Bundle savedInstanceState) { getDelegate().installViewFactory(); getDelegate().onCreate(savedInstanceState); super.onCreate(savedInstanceState); } 由于我们导入的是 support.v7 包里面的AppCompatActivity， getDelegate() 得到的就是AppCompatDelegateImplV7 ，其 onCreate 方法如下： public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mWindowDecor = (ViewGroup) mWindow.getDecorView(); ...... } 就是这里的 mWindow.getDecorView() ，对 DecorView 进行了实例化： public final View getDecorView() { if (mDecor == null) { installDecor(); } return mDecor; } 第一次调用 getDecorView 的时候，会进入 installDecor 方法，这个方法对 DecorView 进行了一系列的初始化 ，其中比较重要的几个方法有：generateDecor / generateLayout 等，generateLayout 会从当前的 Activity 的 Theme 提取相关的属性，设置给 Window，同时还会初始化一个 startingView，添加到 DecorView上，也就是我们所说的 startingWindow。 总结 Decor 有装饰的意思，DecorView 官方注释为 “This is the top-level view of the window, containing the window decor” , 我们可以理解为 DecorView 是我们当前 Activity 的最下面的布局。所以我们打开 DDMS 查看 Tree Overview 的时候，可以发现最根部的那个 View 就是 DecorView： DelayLoad 应用从桌面启动的时候，在主 Activity 还没有显示的时候，如果主题没有设置窗口的背景，那么我们就会看到白色（这个和手机的Rom也有关系），如果应用启动很慢，那么用户得看好一会白色。如果要避免这个，则可以在 Application 或者 Activity 的 Theme 中设置 WindowBackground , 这样就可以避免白色（当然现在各种大厂都是SplashActivity+广告我也是可以理解的） 3. Post 当我们调用 DecorView 的 Post 的时候，其实最终会调用 View 的 Post ，因为 DecorView 最终是继承 View 的： public boolean post(Runnable action) { final AttachInfo attachInfo = mAttachInfo; if (attachInfo != null) { return attachInfo.mHandler.post(action); } // Assume that post will succeed later ViewRootImpl.getRunQueue().post(action); return true; } 注意这里的 mAttachInfo ，我们调用 post 是在 Activity 的 onCreate 中调用的，那么此时 mAttachInfo 是否为空呢？答案是 mAttachInfo 此时为空。 这里有一个点就是 Activity 的各个回调函数都是干嘛的？是不是平时自己写应用的时候，貌似在 onCreate 里面搞定一切就OK了， onResume ？ onStart？没怎么涉及到嘛，其实不然。 onCreate 顾名思义就是 Create ，我们在前面看到，Activity 的 onCreate 函数做了很多初始化的操作，包括 PhoneWindow/DecorView/StartingView/setContentView等，但是 onCreate 只是初始化了这些对象. 真正要设置为显示则在 Resume 的时候，不过这些对开发者是透明了，具体可以看 ActivityThread 的 handleResumeActivity 函数，handleResumeActivity 中除了调用 Activity 的 onResume 回调之外，还初始化了几个比较重要的类：ViewRootImpl / ThreadedRenderer。 ActivityThread.handleResumeActivity: if (r.window == null && !a.mFinished && willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (a.mVisibleFromClient) { a.mWindowAdded = true; wm.addView(decor, l); } 主要是 wm.addView(decor, l); 这句，将 decorView 与 WindowManagerImpl联系起来，这句最终会调用到 WindowManagerGlobal 的 addView 函数， public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { ...... ViewRootImpl root; View panelParentView = null; ...... root = new ViewRootImpl(view.getContext(), display); view.setLayoutParams(wparams); mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { ...... } } 我们知道 ViewRootImpl 是 View 系统的一个核心类，其定义如下： public final class ViewRootImpl implements ViewParent, View.AttachInfo.Callbacks, HardwareRenderer.HardwareDrawCallbacks ViewRootImpl 初始化的时候会对 AttachInfo 进行初始化，这就是为什么之前的在 onCreate 的时候 attachInfo 为空。ViewRootImpl 里面有很多我们比较熟悉也非常重要的方法，比如 performTraversals / performLayout / performMeasure / performDraw / draw 等。 我们继续 addView 中的root.setView(view, wparams, panelParentView); 传入的 view 为 decorView，root 为 ViewRootImpl ，这个函数中将 ViewRootImpl 的mView 变量 设置为传入的view，也就是 decorView。 这样来看，ViewRootImpl 与 DecorView 的关系我们也清楚了。 扯了一圈，我们再回到大标题的 Post 函数上，前面有说这个 Post 走的是 View 的Post 函数，由于 在 onCreate 的时候 attachInfo 为空，所以会走下面的分支：ViewRootImpl.getRunQueue().post(action); 注意这里的 getRunQueue 得到的并不是 Looper 里面的那个 MessageQueue，而是由 ViewRootImpl 维持的一个 RunQueue 对象，其核心为一个 ArrayList ： private final ArrayList mActions = new ArrayList(); void post(Runnable action) { postDelayed(action, 0); } void postDelayed(Runnable action, long delayMillis) { HandlerAction handlerAction = new HandlerAction(); handlerAction.action = action; handlerAction.delay = delayMillis; synchronized (mActions) { mActions.add(handlerAction); } } void executeActions(Handler handler) { synchronized (mActions) { final ArrayList actions = mActions; final int count = actions.size(); for (int i = 0; i 当我们执行了 Post 之后 ，其实只是把 Runnable 封装成一个 HandlerAction 对象存入到 ArrayList 中，当执行到 executeActions 方法的时候，将存在这里的 HandlerAction 再通过 executeActions 方法传入的 Handler 对象重新进行 Post。 那么 executeActions 方法是什么时候执行的呢？传入的 Handler 又是哪个 Handler 呢？ 4. PerformTraversals 我们之前讲过，ViewRootImpl 的 performTraversals 方法是一个很核心的方法，每一帧绘制都会走一遍，调用各种 measure / layout / draw 等 ，最终将要显示的数据交给 hwui 去进行绘制。 我们上一节讲到的 executeActions ，就是在 performTraversals 中执行的： // Execute enqueued actions on every traversal in case a detached view enqueued an action getRunQueue().executeActions(mAttachInfo.mHandler); 可以看到这里传入的 Handler 是 mAttachInfo.mHandler ，上一节讲到 mAttachInfo 是在 ViewRootImpl 初始化的时候一起初始化的： mAttachInfo = new View.AttachInfo(mWindowSession, mWindow, display, this, mHandler, this); 这里的 mHandler 是一个 ViewRootHandler 对象： final class ViewRootHandler extends Handler{ ...... } ...... final ViewRootHandler mHandler = new ViewRootHandler(); 我们注意到 ViewRootHandler 在创建的时候并没有传入一个 Looper 对象，这意味着此 ViewRootHandler 的 Looper 就是 mainLooper。 这下我们就清楚了，我们在 onCreate 中 Post 的 runnable 对象，最终还是在第一个 performTraversals 方法执行的时候，加入到了 MainLooper 的 MessageQueue 里面了。 绕了一圈终于我们终于把文章最前面的那句话解释清楚了，当然中间还有很多的废话，不过我估计能耐着性子看到这里的人会很少，所以如果你看到了这里，可以在底下的评论里面将 index ++ ；这里 index = 0 ；就是看看几个人是真正认真看了这篇文章的。 5. UpdateText 接着 performTraversals 我们继续说，话说在第一篇文章 我们有讲到，Activity 在启动时，会在第二次执行 performTraversals 才会去真正的绘制，原因在于第一次执行 performTraversals 的时候，会走到 Egl 初始化的逻辑，然后会重新执行一次 performTraversals 。 所以前一篇文章的评论区有人问为何在 run 方法里面还要 post 一次，如果在 run 方法里面直接执行 updateText 方法 ，那么 updateText 就会在第一个 performTraversals 之后就执行，而不是在第一帧绘制完成后才去执行，所以我们又 Post 了一次 。所以大概的处理步骤如下： 第一步：Activity.onCreate –> Activity.onStart –> Activity.onResume 第二步：ViewRootImpl.performTraversals –>Runnable 第三步：Runnable –> ViewRootImpl.performTraversals 第四步：ViewRootImpl.performTraversals –> UpdateText 第五步：UpdateText 6. 总结 其实一路跟下来发现其实原理很简单，其实 DelayLoad 其实只是一个很小的点，关键是教大家如何去跟踪一个自己不认识的知识点或者优化，这里面主要用到了两个工具：Systrace 和 Method Trace， 以及源码编译和调试。 关于 Systrace 和 Method Trace 的使用，之后会有详细的文章去介绍，这两个工具非常有助于理解源码和一些技术的实现。 Systrace Systrace Method Trace Method Trace 源码编译与调试 源码编译与调试 代码 本文章所所涉及到的代码我放到了Github上： https://github.com/Gracker/DelayLoadSample Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-14 19:28:09 var className='atoc';"},"Android/疑难杂症/":{"url":"Android/疑难杂症/","title":"疑难杂症","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Android/疑难杂症/Android Studio gradle plugin 太低的解决方案.html":{"url":"Android/疑难杂症/Android Studio gradle plugin 太低的解决方案.html","title":"Android Studio gradle plugin 太低的解决方案","keywords":"","body":"当Androi Studio编译的时候，遇到如下错误 Error:(1, 0) The android gradle plugin version 2.4.0-alpha7 is too old, please update to the latest version. To override this check from the command line please set the ANDROID_DAILY_OVERRIDE environment variable to \"a151637df19e9dbfff417b406bc6cf9cbcb8a8f6\" 使用命令，并重启AS launchctl setenv ANDROID_DAILY_OVERRIDE a151637df19e9dbfff417b406bc6cf9cbcb8a8f6 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Android/疑难杂症/ScrollView嵌套ListView问题.html":{"url":"Android/疑难杂症/ScrollView嵌套ListView问题.html","title":"ScrollView嵌套ListView问题","keywords":"","body":"ScrollView嵌套ListView问题 进入页面不从顶部开始显示的问题解决 解决方案——取消ListView的焦点 listView.setFocusable(false); 实测在代码中通过setFocusable(false)可以解决这个问题 但是在xml里设置Android:focusable=”false”并不起作用 同样的方法适用于GridView Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-20 10:58:08 var className='atoc';"},"Android/疑难杂症/Selector不起作用的解决方案.html":{"url":"Android/疑难杂症/Selector不起作用的解决方案.html","title":"Selector不起作用的解决方案","keywords":"","body":"1. 由于TextView,RelativeLayout(LinearLayout) 默认不具备可点击性的，要让background的selector 起作用有两种方法： 一、在代码中给其设置点击事件OnClickListener 二、在xml中设置clickable = true2. selector写的不对，不点击时的默认效果应该放在最后面 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Tools/Index.html":{"url":"Tools/Index.html","title":"Tools","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Tools/adb 命令.html":{"url":"Tools/adb 命令.html","title":"Adb 命令","keywords":"","body":" Adb 命令 adb shell procrank 查看内存 获取屏幕分辨率 启动一个Acitivy with extras 查看网卡eth0 Adb 命令 adb shell procrank 查看内存 qiaoshouliangdeMacBook-Pro:~ qiaoshouliang$ adb shell procrank PID Vss Rss Pss Uss cmdline 626 442480K 51220K 26367K 23136K com.android.systemui 816 461616K 46436K 22241K 18996K com.dnake.desktop 564 494264K 44776K 19629K 15872K system_server 134 394504K 43204K 12922K 6976K zygote 1238 451920K 37300K 12260K 8556K com.android.settings 731 451776K 37180K 11602K 8164K com.android.phone 713 419972K 31852K 7966K 5176K com.google.android.inputmethod.pinyin 850 408404K 27592K 6748K 4636K android.process.acore 700 407272K 27932K 6550K 4500K android.process.media 786 408204K 24736K 4685K 2892K com.dnake.smart 757 406128K 24640K 4579K 2788K com.dnake.security 771 408188K 24036K 4198K 2624K com.dnake.talk 801 407500K 23692K 4045K 2504K com.dnake.eSettings 136 37032K 7692K 4037K 3212K /system/bin/mediaserver 515 61752K 9340K 3895K 2420K /var/bin/dnake_talk 744 406040K 23184K 3689K 2168K com.dnake.apps 994 403952K 22664K 3580K 1848K com.dnake.d400 552 43888K 8740K 3359K 1888K /var/bin/dnake_media 135 12552K 5028K 2763K 2416K /system/bin/drmserver 1450 2424K 1908K 1675K 1668K procrank 133 57656K 3380K 1504K 1188K /system/bin/surfaceflinger 138 3944K 1264K 603K 552K /system/bin/keystore 131 9752K 1244K 565K 488K /system/bin/netd 130 4676K 1144K 491K 424K /system/bin/vold 1 668K 528K 429K 356K /init 526 7300K 620K 351K 336K /var/bin/dnake_control 185 1116K 608K 339K 328K logcat 140 3524K 504K 229K 220K /system/bin/sdcard 69 584K 304K 228K 156K /sbin/ueventd 141 5620K 232K 220K 220K /sbin/adbd 491 1004K 456K 190K 180K /var/bin/dnake_nvs 137 996K 460K 167K 156K /system/bin/installd 492 1384K 200K 157K 156K /var/bin/monitor 132 1032K 420K 155K 144K /system/bin/debuggerd 490 904K 276K 146K 140K /var/bin/mini_httpd 562 1436K 184K 141K 140K /var/bin/upgrade 127 1424K 144K 140K 140K /sbin/healthd 153 1912K 132K 132K 132K /system/bin/busybox 129 1004K 336K 119K 112K /system/bin/servicemanager 561 856K 352K 106K 96K logwrapper 514 856K 352K 106K 96K logwrapper 525 856K 352K 106K 96K logwrapper 550 856K 348K 102K 92K logwrapper ------ ------ ------ 173532K 128388K TOTAL RAM: 425876K total, 52636K free, 3488K buffers, 164656K cached, 324K shmem, 38128K slab 其中total指的就是系统的内存大小，512M VSS Virtual Set Size 虚拟耗用内存（包含共享库占用的内存） RSS Resident Set Size 实际使用物理内存（包含共享库占用的内存） PSS Proportional Set Size 实际使用的物理内存（比例分配共享库占用的内存） USS Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存） 获取屏幕分辨率 qiaoshouliangdeMacBook-Pro:~ qiaoshouliang$ adb shell wm size Physical size: 1280x800 启动一个Acitivy with extras adb shell am start -n com.hismart.intercom/.StartupActivity --ei START_INTENT 1000 查看网卡eth0 root@android:/ # ifconfig eth0 ifconfig eth0 eth0: ip 192.168.0.180 mask 255.255.255.0 flags [up broadcast running multicast] Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-21 10:04:31 var className='atoc';"},"Tools/Adb 不识别的解决办法.html":{"url":"Tools/Adb 不识别的解决办法.html","title":"Adb 不识别的解决办法","keywords":"","body":"在 android 设备的 Linux 内核中把 USB 驱动的 PID VID 修改以后，也许之前的 adb工具就不能识别设备了，会打印出 \"device not found\" 的提示，特别是 windows ，adb驱动也不能用了。 这个时候该怎么办呢？ 一，先搞清现在的 PID，VID 为多少，例如分别为 aaaa、bbbb（十六进制） 对于 linux 如 ubuntu, 插入 设备，再查询 /sys/bus/usb/ 下的相应设备，如 \"1-1\" 下的idVender, idProduct 获得。 对于 windows, 可从相应设备的属性中获得 二，对于windows: 修改 adb 驱动中的 android_winusb.inf 文件。对照着别的项目加就可以了。 例如： ; My product %CompositeAdbInterface% = USB_Install,USB\\VID_AAAA&PID_BBBB %SingleBootLoaderInterface% = USB_Install,USB\\VID_AAAA&PID_BBBB&MI_01 右击我的电脑->属性->高级->环境变量，添加 ANROID_SDK_HOME 环境变量。如果你有android SDK,就设成SDK的路径；如果没有，那也没关系，设为你觉得方便的任何路径。 在前面设置的ANDROID_SDK_HOME对应的路径下，寻找.android目录，如果没有就创建一个；在.android目录下新建一个文件，叫adb_usb.ini, 记住，后缀是 \"ini\" 哦；添加前面获得的VID 到 adb_usb.ini 中，如 0xAAAA。 然后安装 adb 驱动 进入 DOS cmd, 分别输入 adb kill-server, adbstart-server, adb devices；若能看到 devices 列出，那么就成功了。 注意：要将手机设为MTP模式而不是充电模式 三，对于linux 在用户的 home 目录下，寻找 .android目录，如果没有就创建。在.android目录下新建一个文件，叫adb_usb.ini,记住，后缀是 \"ini\" 哦；添加前面获得的 VID 到 adb_usb.ini 中，如 0xAAAA。 在 shell 中 分别输入 adb kill-server, adbstart-server, adb devices；若能看到 devices 列出，那么就成功了。 这里 kill-server，是 kill 掉 adb 的 daemon，否则，adb 还是保留着先前的 Vender信息。start-server 就加载了新的 Vender 信息。 注意：有些人可能用adb 需要超级用户权限，这时第一步中的home 目录应该为 /root，不想麻烦，直接两个 Home 目录都加上得了。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Tools/Android Studio 3.0 编译报错的解决办法.html":{"url":"Tools/Android Studio 3.0 编译报错的解决办法.html","title":"Android Studio 3.0 编译报错的解决办法","keywords":"","body":"Android Studio 3.0 编译报错的解决办法 Execution failed for task ':app:transformClassesWithProfilers-transformForDebug'. > 7 网上还查到如下这两个问题也是同样的解决办法 Error:Execution failed for task ':lryapp:transformClassesWithProfilers-transformForDebug'. > 4 java.lang.ArrayIndexOutOfBoundsException：4 解决办法如下： 在Run/Debug Configurations中去掉Enable advanced profiling这个选型 这个功能是AS 3.0中的开启高级分析器功能 以下是关于这个功能的介绍，但是为什么会导致:app:transformClassesWithProfilers-transformForDebug'. > 7这个问题，还需要再研究一下。 默认情况下并不是所有的分析数据都可见。如果您看到一条消息，说“Advanced profiling is unavailable for the selected process”，则需要在运行配置中启用高级分析。 为了显示高级分析数据，Android Studio必须将监控逻辑注入到已编译的应用程序中。高级分析提供的功能包括： 所有分析器窗口上的事件时间轴 内存分析器中已分配对象的数量 内存分析器中的垃圾收集事件 有关Network Profiler中所有传输文件的详细信息 要启用高级概要分析，请按照下列步骤操作： 选择 Run > Edit Configurations 在左窗格中选择您的应用程序模块。 单击Profiling选项卡，然后选中Enable advanced profiling.。 现在再次构建并运行应用程序就可以访问完整的概要分析功能集。但是，请注意，高级分析会降低您的构建速度，因此只有在您要开始对应用程序进行概要分析时，才应启用它。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 11:11:30 var className='atoc';"},"Tools/git 命令.html":{"url":"Tools/git 命令.html","title":"git 命令","keywords":"","body":"git 初始化 git init 创建 .git git add . 添加文件到缓存 git remote add origin https://gitee.com/qiaoshouliang/41.git 添加远端库的地址 git pull 从远程库同步代码到本地库 git commit 添加文件到本地库 git push 将本地库代码同步到远端库 git 的常用命令 git stash 讲现有修改缓存下来 git stash pop 讲缓存的内容pop出来 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-04 18:00:41 var className='atoc';"},"Tools/SVN 提交错误解决办法.html":{"url":"Tools/SVN 提交错误解决办法.html","title":"SVN 提交错误解决办法","keywords":"","body":"svn: Commit failed (details follow): svn: '/*/xxx.c' is scheduled for addition, but is missing 删除文件夹后点commit提交，但是报错，报错内容如下： 提示 \"svn: Commit failed (details follow): svn: '/*/xxx.c' is scheduled for addition, but is missing \" 原因： 之前用SVN提交过的文件，被标记为\"add\"状态，等待被加入到仓库。若此时你把这个文件删除了，SVN提交的时候还是会尝试提交这个文件，虽然它的状态已经是 \"missing\"了。 解决： 在命令行下用 \"svn revert xxx.c --depth infinity\"，在图形界面下，右键--Revert，选中那个文件。这样就告诉SVN把这个文件退回到之前的状态 \"unversioned\"，也就是不对这个文件做任何修改 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Tools/Android studio 使用技巧.html":{"url":"Tools/Android studio 使用技巧.html","title":"Android studio 使用技巧","keywords":"","body":" Android Studio Debug的方法 进入 debug 模式的两种姿势 常见的调试操作 设置断点 几种高效断点 条件成立时才触发的条件断点 不会阻塞应用程序的日志断点 被异常触发的异常断点 追踪关键点的字段断点和方法断点 组合使用 调试中的变量 变量观测面板 Add New Watch 设置变量的值 Log Android Studio Lint 使用方法 配置 常见问题 ScrollView size validation Handler reference leaks Memory allocations within drawing code ‘private’ method declared ‘final’ Android Clean Code Android Gradle 一些基本用法 版本号配置 Android Studio 的一些小技巧 代码提示不区别大小写 变量命名提示 去掉不用的import control + option + O 方法注释添加 查找使用 快速进入类 Comand + O 上下移动行 shift + option + up/down 上下复制行 Command + D 多行编辑 ALT+ 鼠标左键 折叠 Command + -/+ 删除一行 Command + Del Android Live Template 三方库 Crash report - bugly Android Studio Debug的方法 进入 debug 模式的两种姿势 第一种是“绿色甲虫”(debug app),一开始就进入了调试模式。它的弊端是每次需要从头跑一遍，且由于调试模式下应用程序略卡顿，等你到达调试页面时会觉得老费劲。 第二种方式是Attach debugger to Android process，选择应用程序主进程，即可进入调试模式。这种方式的特点是，随时随地自由进入调试模式，不需要重头开始跑应用程序，该方式适合绝大多数调试场景。 常见的调试操作 调试界面: 在 Android Studio 的 debug 标签（假如一开始没有，等触发断点后自然会出现）中有两个面板 debugger 和 console。debugger 又分为 Frames、Threads 和 Variables 三块，分别是堆栈内容、线程、变量区。 在 debugger 标签右边有一些操作按钮，是我们常用的调试操作，下面会一一介绍。（可以用鼠标悬停在上面看每个按钮的具体名称） 设置断点 断点有多种类型，我们这里先只谈普通断点。在每行的最前端单击一下即可添加断点，在断点上单击一下是取消断点。普通模式下断点只是一个普通的红点，但假如是在调试模式下，则红点上会有一个“√”或“✘”表示该行是否会被运行，例如，注释行前的断点会是“✘”。 跳到下一个断点（F9） 单步调试（F8） 进入方法内部（F7） 退出当前方法（上档键+F8） 几种高效断点 条件成立时才触发的条件断点 普通断点在每次运行到时都会被触发，这在多次调用、有“循环”的场景会比较麻烦，比如循环 100 次只希望停留在第 98 次。那么此刻就可以用上条件断点了。 添加条件断点：先在需要的行前左键单击添加普通断点，右键点击该断点出现对话框，在“Condition”处填入条件即可，条件语法同 Java，如 i == 98。点击 Done，完成添加。这样当条件未满足时，不会阻塞程序运行；当条件满足时断点被触发。 不会阻塞应用程序的日志断点 被异常触发的异常断点 追踪关键点的字段断点和方法断点 组合使用 比如日志断点是“不阻塞”和“输出日志”两个操作的集合，那么我们当然可以加上“设置条件”操作变成“条件日志断点”。 调试中的变量 在设置了合适的断点后，我们就可以进行下一步操作 —— 观察变量，准确的说是观察变量的值。 变量观测面板 如上图所示，变量观察面板会列出所有当前能访问到的成员变量和局部变量。 点击变量前的箭头，可以将该实例展开，列出所有字段。 Add New Watch 设置变量的值 Log 在多线程环境下，光靠 debug 是不行的。有时 debug 本身会带来一些问题混淆了现场，比如因为 debug 时的卡顿造成环境不一致等等，这时应该学会使用打日志的形式帮忙调试。 Android Studio Lint 使用方法 检查完毕后会弹出 Inspection 的控制台，并在其中列出详细的检查结果： 如上图所展示的，Android Lint 对检查的结果进行了分类，同一个规则（issue）下的问题会聚合，其中针对 Android 的规则类别会在分类前说明是 Android 相关的，主要是六类： Accessibility 无障碍，例如 ImageView 缺少 contentDescription 描述，String 编码字符串等问题。 Correctness 正确性，例如 xml 中使用了不正确的属性值，Java 代码中直接使用了超过最低 SDK 要求的 API 等。 Internationalization 国际化，如字符缺少翻译等问题。 Performance 性能，例如在 onMeasure、onDraw 中执行 new，内存泄露，产生了冗余的资源，xml 结构冗余等。 Security 安全性，例如没有使用 HTTPS 连接 Gradle，AndroidManifest 中的权限问题等。 Usability 易用性，例如缺少某些倍数的切图，重复图标等。 配置 android { lintOptions { // 设置为 true，则当 Lint 发现错误时停止 Gradle 构建 abortOnError false // 设置为 true，则当有错误时会显示文件的全路径或绝对路径 (默认情况下为true) absolutePaths true // 仅检查指定的问题（根据 id 指定） check 'NewApi', 'InlinedApi' // 设置为 true 则检查所有的问题，包括默认不检查问题 checkAllWarnings true // 设置为 true 后，release 构建都会以 Fatal 的设置来运行 Lint。 // 如果构建时发现了致命（Fatal）的问题，会中止构建（具体由 abortOnError 控制） checkReleaseBuilds true // 不检查指定的问题（根据问题 id 指定） disable 'TypographyFractions','TypographyQuotes' // 检查指定的问题（根据 id 指定） enable 'RtlHardcoded','RtlCompat', 'RtlEnabled' // 在报告中是否返回对应的 Lint 说明 explainIssues true // 写入报告的路径，默认为构建目录下的 lint-results.html htmlOutput file(\"lint-report.html\") // 设置为 true 则会生成一个 HTML 格式的报告 htmlReport true // 设置为 true 则只报告错误 ignoreWarnings true // 重新指定 Lint 规则配置文件 lintConfig file(\"default-lint.xml\") // 设置为 true 则错误报告中不包括源代码的行号 noLines true // 设置为 true 时 Lint 将不报告分析的进度 quiet true // 覆盖 Lint 规则的严重程度，例如： severityOverrides [\"MissingTranslation\": LintOptions.SEVERITY_WARNING] // 设置为 true 则显示一个问题所在的所有地方，而不会截短列表 showAll true // 配置写入输出结果的位置，格式可以是文件或 stdout textOutput 'stdout' // 设置为 true，则生成纯文本报告（默认为 false） textReport false // 设置为 true，则会把所有警告视为错误处理 warningsAsErrors true // 写入检查报告的文件（不指定默认为 lint-results.xml） xmlOutput file(\"lint-report.xml\") // 设置为 true 则会生成一个 XML 报告 xmlReport false // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Fatal fatal 'NewApi', 'InlineApi' // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Error error 'Wakelock', 'TextViewEdits' // 将指定问题（根据 id 指定）的严重级别（severity）设置为 Warning warning 'ResourceAsColor' // 将指定问题（根据 id 指定）的严重级别（severity）设置为 ignore ignore 'TypographyQuotes' } } 常见问题 我们在使用 Android Lint 对项目进行检查后，整理了一些问题及解决方法，下面列举较为常见的场景： ScrollView size validation 这也是上文提到过的一个情况，在 ScrollView 的第一层子元素中设置了高度为 match_parent，这是错误的写法，实际上在 measure 时这里必定会被当作 wrap_content 去处理，因此按照 Lint 的建议，直接改为 wrap_content 即可。 Handler reference leaks Handler 引用的内存泄露问题，例如下面的例子： protected static final int STOP = 0x10000; protected static final int NEXT = 0x10001; @BindView(R.id.rectProgressBar) QMUIProgressBar mRectProgressBar; @BindView(R.id.circleProgressBar) QMUIProgressBar mCircleProgressBar; int count; private Handler myHandler = new Handler() { @Override public void handleMessage(Message msg) { super.handleMessage(msg); switch (msg.what) { case STOP: break; case NEXT: if (!Thread.currentThread().isInterrupted()) { mRectProgressBar.setProgress(count); mCircleProgressBar.setProgress(count); } } } }; 首先非静态的内部类或者匿名类会隐式的持有其外部类的引用，内部类使用了外部类的方法/成员变量也会导致其持有外部类引用，因此上面这种情况会导致 handler 持有了外部类，外部类同时持有 handler，handler 是异步的，当 handler 的消息发送出去后，外部类因 hanlder 的持有而无法销毁，最终导致内存泄露。 解决办法则是把该内部类改为 static，内部类中使用的外部类方法/成员变量改为弱引用，具体如下： @BindView(R.id.rectProgressBar) QMUIProgressBar mRectProgressBar; @BindView(R.id.circleProgressBar) QMUIProgressBar mCircleProgressBar; int count; private ProgressHandler myHandler = new ProgressHandler(); @Override protected View onCreateView() { myHandler.setProgressBar(mRectProgressBar, mCircleProgressBar); } private static class ProgressHandler extends Handler { private WeakReference weakRectProgressBar; private WeakReference weakCircleProgressBar; public void setProgressBar(QMUIProgressBar rectProgressBar, QMUIProgressBar circleProgressBar) { weakRectProgressBar = new WeakReference<>(rectProgressBar); weakCircleProgressBar = new WeakReference<>(circleProgressBar); } @Override public void handleMessage(Message msg) { super.handleMessage(msg); switch (msg.what) { case STOP: break; case NEXT: if (!Thread.currentThread().isInterrupted()) { if (weakRectProgressBar.get() != null && weakCircleProgressBar.get() != null) { weakRectProgressBar.get().setProgress(msg.arg1); weakCircleProgressBar.get().setProgress(msg.arg1); } } } } } Memory allocations within drawing code onMeasure、onDraw 都是被频繁调用的方法，因此 Lint 不建议在其中执行 new 操作，可以在 onCreateView 等非频繁调用的时机进行 new 操作，并用成员变量保存，再在 onMeasure 中使用成员变量。 ‘private’ method declared ‘final’ private static final void addLinkMovementMethod(TextView t) { MovementMethod m = t.getMovementMethod(); // ... } 如上面的示例代码，会产生 ‘private’ method declared ‘final’ 的警告，因为私有方法是不会被 override 的，因此完全没有必要声明 final。 Android Clean Code Android Gradle 一些基本用法 版本号配置 project build.gradle app/module build.gradle Android Studio 的一些小技巧 代码提示不区别大小写 使用方法：Editor标签下-Code Completion下-Case sensitive completion选择None，当输入代码，不区别大小写也能弹出代码提示 变量命名提示 变量命名都是用小写m开头，Android Studio提示却是这样的： 如何输入m，提示mRetrofit呢？ 使用方法：Code Style-Java-Code Generation-Fields 输入m，达到预期效果： 去掉不用的import control + option + O 方法注释添加 查找使用 使用方法：将鼠标放在需要查找的类或变量，选择Find Usages 快速进入类 Comand + O 当不勾上Include non-project class搜的是当前Module，勾上是全局的。 上下移动行 shift + option + up/down 上下复制行 Command + D 多行编辑 ALT+ 鼠标左键 折叠 Command + -/+ 删除一行 Command + Del Android Live Template 三方库 Crash report - bugly https://bugly.qq.com/v2/crash-reporting/crashes/eef48e1f98/2?pid=1 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-16 16:49:40 var className='atoc';"},"Tools/Systrace的使用.html":{"url":"Tools/Systrace的使用.html","title":"Systrace的使用","keywords":"","body":"Systrace启动 你可以通过命令行或者Device Monitor两种方式收集Systrace信息，以下以命令行为例介绍收集方式(因为我Device Monitor的方式报错)。 首先进入sdk下的platform-tools/systrace目录下: 然后在命令下执行以下命令来收集数据: python systrace.py --time=10 -o mynewtrace.html sched gfx view wm 为了方便起见我们会使用alias的方式 alias st-start='/Users/qiaoshouliang/Library/Android/sdk/platform-tools/systrace/systrace.py' alias systrace='st-start -t 8 gfx input view sched freq wm am hwui workq res dalvik sync disk load perf hal rs idle mmc' 以后直接就可以用systrace命令生产trace文件 上面的参数–time为间隔时间,-o为文件名，更详细的参数信息如下: 参数名 意义 -h,--help 帮助信息 -o 保存的文件名 -t N,--time=N 多少秒内的数据，默认为5秒，以当前时间点往后倒N个时间 -b N,--buf-size=N 单位为千字节,限制数据大小 -k --ktrace= 追踪特殊的方法 -l,--list-categories 设置追踪的标签 -a ,--app= 包名 --from-file= 创建报告的来源trace文件 -e ,--serial= 设备号 其中标签可选项如下: 标签名 意义 gfx Graphics input Input view View webview Webview vm Window Manager am Activity Manager audio Audio video Video camera Camera hal Hardware Modules res Resource Loading dalvik Dalvik VM rs RenderScript sched Cpu Scheduling freq Cpu Frequency membus Memory Bus Utilization idle Cpu Idle disk Disk input and output load Cpu Load sync Synchronization Manager workq Kernel Workqueues 以上标签并不支持所有机型,还有要想在输出中看到任务的名称，需要加上sched. 上面的命令执行完后，会生成一个html文件: 打开该文件后，我们会看到如下页面: systrace快捷键 快捷键 作用 w 放大 s 缩小 a 左移 d 右移 f 返回选中区域，切放大选中区域 Alerts Alerts一栏标记了以下性能有问题的点，你可以点击该点查看详细信息,右边侧边栏还有一个Alerts框，点击可以查看每个类型的Alerts的数量: Frame 在每个包下都有Frame一栏，该栏中都有一个一个的F代表每一个Frame，用颜色来代表性能的好坏，依次为绿-黄-红(性能越来越差),点击某一个F,会显示该Frame绘制过程中的一些Alerts信息: 如果你想查看Frame的耗时，可以点击某个F标志，然后按m键: Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-15 09:50:41 var className='atoc';"},"Java/Index.html":{"url":"Java/Index.html","title":"Java","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Java/查看端口是否占用.html":{"url":"Java/查看端口是否占用.html","title":"查看端口是否占用","keywords":"","body":"命令 lsof -i tcp:port （port替换成端口号，比如6379） 可以查看该端口被什么程序占用，并显示PID，方便KILL Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Java/深入理解Java String及intern.html":{"url":"Java/深入理解Java String及intern.html","title":"深入理解Java String及intern","keywords":"","body":"字符串问题 代码段一： package com.paddx.test.string; public class StringTest { public static void main(String[] args) { String str1 = \"string\"; String str2 = new String(\"string\"); String str3 = str2.intern(); System.out.println(str1==str2);//#1 System.out.println(str1==str3);//#2 } } 代码段二： package com.paddx.test.string; public class StringTest01 { public static void main(String[] args) { String baseStr = \"baseStr\"; final String baseFinalStr = \"baseStr\"; String str1 = \"baseStr01\"; String str2 = \"baseStr\"+\"01\"; String str3 = baseStr + \"01\"; String str4 = baseFinalStr+\"01\"; String str5 = new String(\"baseStr01\").intern(); System.out.println(str1 == str2);//#3 System.out.println(str1 == str3);//#4 System.out.println(str1 == str4);//#5 System.out.println(str1 == str5);//#6 } } 代码段三（1）: package com.paddx.test.string;　 public class InternTest { public static void main(String[] args) { String str2 = new String(\"str\")+new String(\"01\"); str2.intern(); String str1 = \"str01\"; System.out.println(str2==str1);//#7 } } 代码段三（2）： package com.paddx.test.string; public class InternTest01 { public static void main(String[] args) { String str1 = \"str01\"; String str2 = new String(\"str\")+new String(\"01\"); str2.intern(); System.out.println(str2 == str1);//#8 } } 　为了方便描述，我对上述代码的输出结果由#1~#8进行了编码，下文中蓝色字体部分即为结果。 字符串深入分析 代码段一 分析 　　字符串不属于基本类型，但是可以像基本类型一样，直接通过字面量赋值，当然也可以通过new来生成一个字符串对象。不过通过字面量赋值的方式和new的方式生成字符串有本质的区别： 　　通过字面量赋值创建字符串时，会优先在常量池中查找是否已经存在相同的字符串，倘若已经存在，栈中的引用直接指向该字符串；倘若不存在，则在常量池中生成一个字符串，再将栈中的引用指向该字符串。而通过new的方式创建字符串时，就直接在堆中生成一个字符串的对象（备注，JDK 7 以后，HotSpot 已将常量池从永久代转移到了堆中。详细信息可参考《JDK8内存模型-消失的PermGen》一文），栈中的引用指向该对象。对于堆中的字符串对象，可以通过 intern() 方法来将字符串添加的常量池中，并返回指向该常量的引用。 现在我们应该能很清楚代码段一的结果了： 结果 #1：因为str1指向的是字符串中的常量，str2是在堆中生成的对象，所以str1==str2返回false。 结果 #2：str2调用intern方法，会将str2中值（“string”）复制到常量池中，但是常量池中已经存在该字符串（即str1指向的字符串），所以直接返回该字符串的引用，因此str1==str2返回true。 以下运行代码段一的代码的结果： 代码段二 分析 对于代码段二的结果，还是通过反编译StringTest01.class文件比较容易理解： 常量池内容（部分）： 执行指令（部分，第二列#+序数对应常量池中的项）： 在解释上述执行过程之前，先了解两条指令： ldc：Push item from run-time constant pool，从常量池中加载指定项的引用到栈。 astore_：Store reference into local variable，将引用赋值给第n个局部变量。 现在我们开始解释代码段二的执行过程： 0: ldc #2：加载常量池中的第二项（\"baseStr\"）到栈中。 2: astore_1 ：将1中的引用赋值给第一个局部变量，即String baseStr = \"baseStr\"； 3: ldc #2：加载常量池中的第二项（\"baseStr\"）到栈中。 5: astore_2 ：将3中的引用赋值给第二个局部变量，即 final String baseFinalStr=\"baseStr\"； 6: ldc #3：加载常量池中的第三项（\"baseStr01\"）到栈中。 8: astore_3 ：将6中的引用赋值给第三个局部变量，即String str1=\"baseStr01\"; 9: ldc #3：加载常量池中的第三项（\"baseStr01\"）到栈中。 11: astore 4：将9中的引用赋值给第四个局部变量：即String str2=\"baseStr01\"； 结果#3：str1==str2 肯定会返回true，因为str1和str2都指向常量池中的同一引用地址。所以其实在JAVA 1.6之后，常量字符串的“+”操作，编译阶段直接会合成为一个字符串。 13: new #4：生成StringBuilder的实例。 16: dup 　　　　 ：复制13生成对象的引用并压入栈中。 17: invokespecial #5：调用常量池中的第五项，即StringBuilder.方法。 以上三条指令的作用是生成一个StringBuilder的对象。 20: aload_1　　：加载第一个参数的值，即\"baseStr\" 21: invokevirtual #6 ：调用StringBuilder对象的append方法。 24: ldc #7：加载常量池中的第七项（\"01\"）到栈中。 26: invokevirtual #6：调用StringBuilder.append方法。 29: invokevirtual #8：调用StringBuilder.toString方法。 32: astore 5：将29中的结果引用赋值改第五个局部变量，即对变量str3的赋值。 结果 #4：因为str3实际上是stringBuilder.append()生成的结果，所以与str1不相等，结果返回false。 34: ldc #3：加载常量池中的第三项（\"baseStr01\"）到栈中。 36: astore 6：将34中的引用赋值给第六个局部变量，即str4=\"baseStr01\"; 结果 #5 ：因为str1和str4指向的都是常量池中的第三项，所以str1==str4返回true。这里我们还能发现一个现象，对于final字段，编译期直接进行了常量替换，而对于非final字段则是在运行期进行赋值处理的。 38: new #9：创建String对象 41: dup ：复制引用并压如栈中。 42: ldc #3：加载常量池中的第三项（\"baseStr01\"）到栈中。 44: invokespecial #10：调用String.\"\"方法，并传42步骤中的引用作为参数传入该方法。 47: invokevirtual #11：调用String.intern方法。 从38到41的对应的源码就是new String(\"baseStr01\").intern()。 50: astore 7：将47步返回的结果赋值给变量7，即str5指向baseStr01在常量池中的位置。 结果 #6 ：因为str5和str1都指向的都是常量池中的同一个字符串，所以str1==str5返回true。 运行代码段二，输出结果如下： 3、代码段三解析： 对于代码段三，在 JDK 1.6 和 JDK 1.7中的运行结果不同。我们先看一下运行结果，然后再来解释其原因： JDK 1.6 下的运行结果： JDK 1.7 下的运行结果： 根据对代码段一的分析，应该可以很简单得出 JDK 1.6 的结果，因为 str2 和 str1本来就是指向不同的位置，理应返回false。 比较奇怪的问题在于JDK 1.7后，对于第一种情况返回true，但是调换了一下位置返回的结果就变成了false。这个原因主要是从JDK 1.7后，HotSpot 将常量池从永久代移到了元空间，正因为如此，JDK 1.7 后的intern方法在实现上发生了比较大的改变，JDK 1.7后，intern方法还是会先去查询常量池中是否有已经存在，如果存在，则返回常量池中的引用，这一点与之前没有区别，区别在于，如果在常量池找不到对应的字符串，则不会再将字符串拷贝到常量池，而只是在常量池中生成一个对原字符串的引用。所以: ==结果 #7：在第一种情况下，因为常量池中没有“str01”这个字符串，所以会在常量池中生成一个对堆中的“str01”的引用，而在进行字面量赋值的时候，常量池中已经存在，所以直接返回该引用即可，因此str1和str2都指向堆中的字符串，返回true。== ==结果 #8：调换位置以后，因为在进行字面量赋值（String str1 = \"str01\"）的时候，常量池中不存在，所以str1指向的常量池中的位置，而str2指向的是堆中的对象，再进行intern方法时，对str1和str2已经没有影响了，所以返回false。== 三、常见面试题解答 有了对以上的知识的了解，我们现在再来看常见的面试或笔试题就很简单了： Q：String s = new String(\"xyz\")，创建了几个String Object? A：两个，常量池中的\"xyz\"和堆中对象。 Q：下列程序的输出结果： String s1 = “abc”; String s2 = “abc”; System.out.println(s1 == s2); A：true，均指向常量池中对象。 Q：下列程序的输出结果： String s1 = new String(“abc”); String s2 = new String(“abc”); System.out.println(s1 == s2); A：false，两个引用指向堆中的不同对象。 Q：下列程序的输出结果： String s1 = “abc”; String s2 = “a”; String s3 = “bc”; String s4 = s2 + s3; System.out.println(s1 == s4); A：false，因为s2+s3实际上是使用StringBuilder.append来完成，会生成不同的对象。 Q：下列程序的输出结果： String s1 = “abc”; final String s2 = “a”; final String s3 = “bc”; String s4 = s2 + s3; System.out.println(s1 == s4); A：true，因为final变量在编译后会直接替换成对应的值，所以实际上等于s4=\"a\"+\"bc\"，而这种情况下，编译器会直接合并为s4=\"abc\"，所以最终s1==s4。 Q：下列程序的输出结果： String s = new String(\"abc\"); String s1 = \"abc\"; String s2 = new String(\"abc\"); System.out.println(s == s1.intern()); System.out.println(s == s2.intern()); System.out.println(s1 == s2.intern()); A：false，false，true，具体原因参考第二部分内容。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Java/Java整形值得缓存机制.html":{"url":"Java/Java整形值得缓存机制.html","title":"Java整形值得缓存机制","keywords":"","body":"缓存范围： Java 为整型值包装类 Byte、Character、Short、Integer、Long 设置了缓存，用于存储一定范围内的值，详细如下： 类型 缓存值范围 Byte -128 ~ 127 Character 0 ~ 127 Short -128 ~ 127 Integer -128 ~ 127（可配置） Long -128 ~ 127 例子： 在一些情况下，比如自动装箱时，如果值在缓存值范围内，将不创建新对象，直接从缓存里取出对象返回，比如： Integer v1 = 10; Integer v2 = 10; Integer v3 = new Integer(10); Integer v4 = 128; Integer v5 = 128; Integer v6 = Integer.valueOf(10); System.out.println(v1 == v2); // true System.out.println(v1 == v3); // false System.out.println(v4 == v5); // false System.out.println(v1 == v6); // true 缓存实现机制： 这里使用了设计模式享元模式。 以 Short 类实现源码为例： // ...public final class Short extends Number implements Comparable { // ... private static class ShortCache { private ShortCache(){} static final Short cache[] = new Short[-(-128) + 127 + 1]; static { for(int i = 0; i = -128 && sAsInt 在第一次调用到 Short.valueOf(short) 方法时，将创建 -128 ~ 127 对应的 256 个对象缓存到堆内存里。 这种设计，在频繁用到这个范围内的值的时候效率较高，可以避免重复创建和回收对象，否则有可能闲置较多对象在内存中。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Java/Java值传递和引用传递.html":{"url":"Java/Java值传递和引用传递.html","title":"Java值传递和引用传递","keywords":"","body":"java的值传递和引用传递在面试中一般都会都被涉及到，今天我们就来聊聊这个问题，首先我们必须认识到这个问题一般是相对函数而言的，也就是java中的方法参数，那么我们先来回顾一下在程序设计语言中有关参数传递给方法（或函数）的两个专业术语： 按值调用（call by value） 按引用调用（call by reference） 所谓的按值调用表示方法接收的是调用着提供的值，而按引用调用则表示方法接收的是调用者提供的变量地址(如果是C语言的话来说就是指针啦，当然java并没有指针的概念)。这里我们需要注意的是一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值，这句话相当重要，这是按值调用与引用调用的根本区别，当然如果还不理解，没关系，下面就要图文并茂的彻底分析啦。 前面我们说过java中并不存在引用调用，这点是没错的，因为java程序设计语言确实是采用了按值调用，即call by value。也就是说方法得到的是所有参数值的一个拷贝，方法并不能修改传递给它的任何参数变量的内容。下面我们来看一个例子： package com.zejian.test; /** * java中的按值调用 * @author zejian */ public class CallByValue { private static int x=10; public static void updateValue(int value){ value = 3 * value; } public static void main(String[] args) { System.out.println(\"调用前x的值：\"+x); updateValue(x); System.out.println(\"调用后x的值：\"+x); } } 运行程序，结果如下： 调用前x的值：10 调用后x的值：10 可以看到x的值并没有变化，接下来我们一起来看一下具体的执行过程： 分析： 1）value被初始化为x值的一个拷贝（也就是10） 2）value被乘以3后等于30，但注意此时x的值仍为10！ 3）这个方法结束后，参数变量value不再使用，被回收。 结论：当传递方法参数类型为基本数据类型（数字以及布尔值）时，一个方法是不可能修改一个基本数据类型的参数。 当然java中除了基本数据类型还有引用数据类型，也就是对象引用，那么对于这种数据类型又是怎么样的情况呢？我们还是一样先来看一个例子： 声明一个User对象类型： package com.zejian.test; public class User { private String name; private int age; public User(String name, int age) { this.name=name; this.age=age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 执行类如下： package com.zejian.test; /** * java中的按值调用 * @author zejian */ public class CallByValue { private static User user=null; public static void updateUser(User student){ student.setName(\"Lishen\"); student.setAge(18); } public static void main(String[] args) { user = new User(\"zhangsan\",26); System.out.println(\"调用前user的值：\"+user.toString()); updateUser(user); System.out.println(\"调用后user的值：\"+user.toString()); } } 运行结果如下： 调用前user的值：User [name=zhangsan, age=26] 调用后user的值：User [name=Lishen, age=18] 很显然，User的值被改变了，也就是说方法参数类型如果是引用类型的话，引用类型对应的值将会被修改，下面我们来分析一下这个过程： 过程分析： student变量被初始化为user值的拷贝，这里是一个对象的引用。 调用student变量的set方法作用在这个引用对象上，user和student同时引用的User对象内部值被修改。 方法结束后，student变量不再使用，被释放，而user还是没有变，依然指向User对象。 结论：当传递方法参数类型为引用数据类型时，一个方法将修改一个引用数据类型的参数所指向对象的值。 虽然到这里两个数据类型的传递都分析完了，也明白的基本数据类型的传递和引用数据类型的传递区别，前者将不会修改原数据的值，而后者将会修改引用所指向对象的值。可通过上面的实例我们可能就会觉得java同时拥有按值调用和按引用调用啊，可惜的是这样的理解是有误导性的，虽然上面引用传递表面上体现了按引用调用现象，但是java中确实只有按值调用而没有按引用调用。到这里估计不少人都蒙逼了，下面我们通过一个反例来说明（回忆一下开头我们所说明的按值调用与按引用调用的根本区别）。 package com.zejian.test; /** * java中的按值调用 * @author zejian */ public class CallByValue { private static User user=null; private static User stu=null; /** * 交换两个对象 * @param x * @param y */ public static void swap(User x,User y){ User temp =x; x=y; y=temp; } public static void main(String[] args) { user = new User(\"user\",26); stu = new User(\"stu\",18); System.out.println(\"调用前user的值：\"+user.toString()); System.out.println(\"调用前stu的值：\"+stu.toString()); swap(user,stu); System.out.println(\"调用后user的值：\"+user.toString()); System.out.println(\"调用后stu的值：\"+stu.toString()); } } 我们通过一个swap函数来交换两个变量user和stu的值，在前面我们说过，如果是按引用调用那么一个方法可以修改传递引用所对应的变量值，也就是说如果java是按引用调用的话，那么swap方法将能够实现数据的交换，而实际运行结果是： 调用前user的值：User [name=user, age=26] 调用前stu的值：User [name=stu, age=18] 调用后user的值：User [name=user, age=26] 调用后stu的值：User [name=stu, age=18] 我们发现user和stu的值并没有发生变化，也就是方法并没有改变存储在变量user和stu中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝的值而已，最终，所做的事都是白费力气罢了。在方法结束后x，y将被丢弃，而原来的变量user和stu仍然引用这个方法调用之前所引用的对象。 这个过程也充分说明了java程序设计语言对对象采用的不是引用调用，实际上是对象引用进行的是值传递，当然在这里我们可以简单理解为这就是按值调用和引用调用的区别，而且必须明白即使java函数在传递引用数据类型时，也只是拷贝了引用的值罢了，之所以能修改引用数据是因为它们同时指向了一个对象，但这仍然是按值调用而不是引用调用。 总结： 一个方法不能修改一个基本数据类型的参数（数值型和布尔型）。 一个方法可以修改一个引用所指向的对象状态，但这仍然是按值调用而非引用调用。 上面两种传递都进行了值拷贝的过程。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Java/CountDownLatch，CyclicBarrier，Samaphore用法.html":{"url":"Java/CountDownLatch，CyclicBarrier，Samaphore用法.html","title":"CountDownLatch，CyclicBarrier，Samaphore用法","keywords":"","body":"在java 1.5中，提供了一些非常有用的辅助类来帮助我们进行并发编程，比如CountDownLatch，CyclicBarrier和Semaphore，今天我们就来学习一下这三个辅助类的用法。 以下是本文目录大纲： CountDownLatch用法 CyclicBarrier用法 Semaphore用法 CountDownLatch用法 CountDownLatch类位于java.util.concurrent包下，利用它可以实现类似计数器的功能。比如有一个任务A，它要等待其他4个任务执行完毕之后才能执行，此时就可以利用CountDownLatch来实现这种功能了。 CountDownLatch类只提供了一个构造器： public CountDownLatch(int count) { }; //参数count为计数值 然后下面这3个方法是CountDownLatch类中最重要的方法： public void await() throws InterruptedException { }; //调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行 public boolean await(long timeout, TimeUnit unit) throws InterruptedException { }; //和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行 public void countDown() { }; //将count值减1 下面看一个例子大家就清楚CountDownLatch的用法了： public class Test { public static void main(String[] args) { final CountDownLatch latch = new CountDownLatch(2); new Thread(){ public void run() { try { System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } }; }.start(); new Thread(){ public void run() { try { System.out.println(\"子线程\"+Thread.currentThread().getName()+\"正在执行\"); Thread.sleep(3000); System.out.println(\"子线程\"+Thread.currentThread().getName()+\"执行完毕\"); latch.countDown(); } catch (InterruptedException e) { e.printStackTrace(); } }; }.start(); try { System.out.println(\"等待2个子线程执行完毕...\"); latch.await(); System.out.println(\"2个子线程已经执行完毕\"); System.out.println(\"继续执行主线程\"); } catch (InterruptedException e) { e.printStackTrace(); } } } 执行结果： 线程Thread-0正在执行 线程Thread-1正在执行 等待2个子线程执行完毕... 线程Thread-0执行完毕 线程Thread-1执行完毕 2个子线程已经执行完毕 继续执行主线程 CyclicBarrier用法 字面意思回环栅栏，通过它可以实现让一组线程等待至某个状态之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。我们暂且把这个状态就叫做barrier，当调用await()方法之后，线程就处于barrier了。 CyclicBarrier类位于java.util.concurrent包下，CyclicBarrier提供2个构造器： public CyclicBarrier(int parties, Runnable barrierAction) { } public CyclicBarrier(int parties) { } 参数parties指让多少个线程或者任务等待至barrier状态；参数barrierAction为当这些线程都达到barrier状态时会执行的内容。 然后CyclicBarrier中最重要的方法就是await方法，它有2个重载版本： public int await() throws InterruptedException, BrokenBarrierException { }; public int await(long timeout, TimeUnit unit)throws InterruptedException,BrokenBarrierException,TimeoutException { }; 第一个版本比较常用，用来挂起当前线程，直至所有线程都到达barrier状态再同时执行后续任务； 第二个版本是让这些线程等待至一定的时间，如果还有线程没有到达barrier状态就直接让到达barrier的线程执行后续任务。 下面举几个例子就明白了： 假若有若干个线程都要进行写数据操作，并且只有所有线程都完成写数据操作之后，这些线程才能继续做后面的事情，此时就可以利用CyclicBarrier了： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 执行结果： 线程Thread-0正在写入数据... 线程Thread-3正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 从上面输出结果可以看出，每个写入线程执行完写数据操作之后，就在等待其他线程写入操作完毕。 当所有线程线程写入操作完毕之后，所有线程就继续进行后续的操作了。 如果说想在所有线程写入操作完之后，进行额外的其他操作可以为CyclicBarrier提供Runnable参数： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N,new Runnable() { @Override public void run() { System.out.println(\"当前线程\"+Thread.currentThread().getName()); } }); for(int i=0;i 运行结果： 线程Thread-0正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2正在写入数据... 线程Thread-3正在写入数据... 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 当前线程Thread-3 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 所有线程写入完毕，继续处理其他任务... 从结果可以看出，当四个线程都到达barrier状态后，会从四个线程中选择一个线程去执行Runnable。 下面看一下为await指定时间的效果： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 执行结果： 线程Thread-0正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1正在写入数据... 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-3正在写入数据... java.util.concurrent.TimeoutException Thread-1所有线程写入完毕，继续处理其他任务... Thread-0所有线程写入完毕，继续处理其他任务... at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) java.util.concurrent.BrokenBarrierException at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) Thread-2所有线程写入完毕，继续处理其他任务... java.util.concurrent.BrokenBarrierException 线程Thread-3写入数据完毕，等待其他线程写入完毕 at java.util.concurrent.CyclicBarrier.dowait(Unknown Source) at java.util.concurrent.CyclicBarrier.await(Unknown Source) at com.cxh.test1.Test$Writer.run(Test.java:58) Thread-3所有线程写入完毕，继续处理其他任务... 上面的代码在main方法的for循环中，故意让最后一个线程启动延迟，因为在前面三个线程都达到barrier之后，等待了指定的时间发现第四个线程还没有达到barrier，就抛出异常并继续执行后面的任务。 另外CyclicBarrier是可以重用的，看下面这个例子： public class Test { public static void main(String[] args) { int N = 4; CyclicBarrier barrier = new CyclicBarrier(N); for(int i=0;i 执行结果： 线程Thread-0正在写入数据... 线程Thread-1正在写入数据... 线程Thread-3正在写入数据... 线程Thread-2正在写入数据... 线程Thread-1写入数据完毕，等待其他线程写入完毕 线程Thread-3写入数据完毕，等待其他线程写入完毕 线程Thread-2写入数据完毕，等待其他线程写入完毕 线程Thread-0写入数据完毕，等待其他线程写入完毕 Thread-0所有线程写入完毕，继续处理其他任务... Thread-3所有线程写入完毕，继续处理其他任务... Thread-1所有线程写入完毕，继续处理其他任务... Thread-2所有线程写入完毕，继续处理其他任务... CyclicBarrier重用 线程Thread-4正在写入数据... 线程Thread-5正在写入数据... 线程Thread-6正在写入数据... 线程Thread-7正在写入数据... 线程Thread-7写入数据完毕，等待其他线程写入完毕 线程Thread-5写入数据完毕，等待其他线程写入完毕 线程Thread-6写入数据完毕，等待其他线程写入完毕 线程Thread-4写入数据完毕，等待其他线程写入完毕 Thread-4所有线程写入完毕，继续处理其他任务... Thread-5所有线程写入完毕，继续处理其他任务... Thread-6所有线程写入完毕，继续处理其他任务... Thread-7所有线程写入完毕，继续处理其他任务... 从执行结果可以看出，在初次的4个线程越过barrier状态后，又可以用来进行新一轮的使用。而CountDownLatch无法进行重复使用。 Semaphore用法 Semaphore翻译成字面意思为信号量，Semaphore可以控同时访问的线程个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可。 Semaphore类位于java.util.concurrent包下，它提供了2个构造器： public Semaphore(int permits) { //参数permits表示许可数目，即同时可以允许多少线程进行访问 sync = new NonfairSync(permits); } public Semaphore(int permits, boolean fair) { //这个多了一个参数fair表示是否是公平的，即等待时间越久的越先获取许可 sync = (fair)? new FairSync(permits) : new NonfairSync(permits); } 下面说一下Semaphore类中比较重要的几个方法，首先是acquire()、release()方法： public void acquire() throws InterruptedException { } //获取一个许可 public void acquire(int permits) throws InterruptedException { } //获取permits个许可 public void release() { } //释放一个许可 public void release(int permits) { } //释放permits个许可 acquire()用来获取一个许可，若无许可能够获得，则会一直等待，直到获得许可。 release()用来释放许可。注意，在释放许可之前，必须先获获得许可。 这4个方法都会被阻塞，如果想立即得到执行结果，可以使用下面几个方法： public boolean tryAcquire() { }; //尝试获取一个许可，若获取成功，则立即返回true，若获取失败，则立即返回false public boolean tryAcquire(long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取一个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false public boolean tryAcquire(int permits) { }; //尝试获取permits个许可，若获取成功，则立即返回true，若获取失败，则立即返回false public boolean tryAcquire(int permits, long timeout, TimeUnit unit) throws InterruptedException { }; //尝试获取permits个许可，若在指定的时间内获取成功，则立即返回true，否则则立即返回false 另外还可以通过availablePermits()方法得到可用的许可数目。 下面通过一个例子来看一下Semaphore的具体使用： 假若一个工厂有5台机器，但是有8个工人，一台机器同时只能被一个工人使用，只有使用完了，其他工人才能继续使用。那么我们就可以通过Semaphore来实现： public class Test { public static void main(String[] args) { int N = 8; //工人数 Semaphore semaphore = new Semaphore(5); //机器数目 for(int i=0;i 执行结果： 工人0占用一个机器在生产... 工人1占用一个机器在生产... 工人2占用一个机器在生产... 工人4占用一个机器在生产... 工人5占用一个机器在生产... 工人0释放出机器 工人2释放出机器 工人3占用一个机器在生产... 工人7占用一个机器在生产... 工人4释放出机器 工人5释放出机器 工人1释放出机器 工人6占用一个机器在生产... 工人3释放出机器 工人7释放出机器 工人6释放出机器 总结 下面对上面说的三个辅助类进行一个总结： CountDownLatch和CyclicBarrier都能够实现线程之间的等待，只不过它们侧重点不同： CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； 另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的。 Semaphore其实和锁有点类似，它一般用于控制对某组资源的访问权限。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-12-04 17:07:16 var className='atoc';"},"Mysql/Index.html":{"url":"Mysql/Index.html","title":"Mysql","keywords":"","body":"记录Android相关的知识点 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 14:19:44 var className='atoc';"},"Mysql/高性能MySQL笔记.html":{"url":"Mysql/高性能MySQL笔记.html","title":"高性能MySQL笔记","keywords":"","body":"ACID ACID，指数据库事务正确执行的四个基本要素的缩写。包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability） LOCK TABLES 的注意事项 除了事物中禁用了AUTOCOMMIT，可以使用LOCK TABLES之外，其他任何时候都不要显式执行LOCK TABLES，不管是使用什么存储引擎。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Mysql/设置MySql的慢查询.html":{"url":"Mysql/设置MySql的慢查询.html","title":"设置MySql的慢查询","keywords":"","body":"慢查询日志配置 1. 显示慢查询的配置项 show variables like '%slow%'; +---------------------------+------------------------------------------+ | Variable_name | Value | +---------------------------+------------------------------------------+ | log_slow_admin_statements | OFF | | log_slow_slave_statements | OFF | | slow_launch_time | 2 | | slow_query_log | ON | | slow_query_log_file | /usr/local/mysql/data/localhost-slow.log | +---------------------------+------------------------------------------+ 5 rows in set (0.00 sec) 2. 修改其中的某一条数据 set global slow_query_log=on; MySQL 慢查询的相关参数解释： slow_query_log ：是否开启慢查询日志，1表示开启，0表示关闭。 log-slow-queries ：旧版（5.6以下版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log slow-query-log-file：新版（5.6及以上版本）MySQL数据库慢查询日志存储路径。可以不设置该参数，系统则会默认给一个缺省的文件host_name-slow.log long_query_time ：慢查询阈值，当查询时间多于设定的阈值时，记录日志。 log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）。 log_output：日志存储方式。log_output='FILE'表示将日志存入文件，默认值是'FILE'。log_output='TABLE'表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output='FILE,TABLE'。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Mysql/数据库操作工具LitePal的使用说明.html":{"url":"Mysql/数据库操作工具LitePal的使用说明.html","title":"数据库操作工具LitePal的使用说明","keywords":"","body":"github地址 https://github.com/LitePalFramework/LitePal#latest-downloads/ 可以在github上查看LitePal的使用说明。 Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"},"Mysql/MySql的常用命令.html":{"url":"Mysql/MySql的常用命令.html","title":"MySql的常用命令","keywords":"","body":"修改提示符的命令如下所示： mysql> PROMPT \\u@\\h \\d> PROMPT set to '\\u@\\h \\d>' root@127.0.0.1 (none)>USE test Database changed root@127.0.0.1 test> 查询表列的信息 root@localhost test>show columns from tdb_goods; +-------------+------------------------+------+-----+---------+----------------+ | Field | Type | Null | Key | Default | Extra | +-------------+------------------------+------+-----+---------+----------------+ | goods_id | smallint(5) unsigned | NO | PRI | NULL | auto_increment | | goods_name | varchar(150) | NO | | NULL | | | goods_cate | varchar(40) | NO | | NULL | | | brand_name | varchar(40) | NO | | NULL | | | goods_price | decimal(15,3) unsigned | NO | | 0.000 | | | is_show | smallint(6) | NO | | 1 | | | is_saleoff | smallint(6) | NO | | 0 | | +-------------+------------------------+------+-----+---------+----------------+ 修改mysql的结束符 DELIMITER // 将 ；结束符改为了 // 分配guru2b用户在firstdb数据库下的所有权限 grant all on firstdb.* to guru2b@localhost identified by '112233'; 用CONCAT连接列 SELECT concat(first_name,\" \",surnname) from sales_rep; 'Sol Rive' 'charlene Gordimer' 'Mike Serote' 'Mongane Rive' 'Mike Smith' 批量存数数据库 数据的格式入下： 数据之间使用tab键来分割，使用回车来换行表明改行数据已经数据完毕 /Users/qiaoshouliang/Desktop/sales.sql 1 1 1 2000 2 4 3 250 3 2 3 500 4 1 4 450 5 3 1 3800 6 1 2 500 load data local infile '/Users/qiaoshouliang/Desktop/sales.sql' into table sales; Copyright © josen 2017 all right reserved，powered by Gitbook该文件修订时间： 2017-11-13 09:33:27 var className='atoc';"}}